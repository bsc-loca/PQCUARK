//==========================================================================
//==               Copyright (c) 2025 Synopsys, Inc.
//==     All Rights reserved - Unpublished - rights reserved under
//==     the Copyright laws of the United States of America.
//== 
//== U.S. Patents: 7,093,156 B1 and 7,406,620 B2 (and more pending).
//== 
//== This file includes the Confidential information of Synopsys, Inc.
//== and GLOBALFOUNDRIES.
//== The receiver of this Confidential Information shall not disclose
//== it to any third party and shall protect its confidentiality by
//== using the same degree of care, but not less than a reasonable
//== degree of care, as the receiver uses to protect receiver's own
//== Confidential Information.
//== Licensee acknowledges and agrees that all output generated for
//== Licensee by Synopsys, Inc. as described in the pertinent Program
//== Schedule(s), or generated by Licensee through use of any Compiler
//== licensed hereunder contains information that complies with the
//== Virtual Component Identification Physical Tagging Standard (VCID)
//== as maintained by the Virtual Socket Interface Alliance (VSIA).
//== Such information may be expressed in GDSII Layer 63 or other such
//== layer designated by the VSIA, hardware definition languages, or
//== other formats. Licensee is not authorized to alter or change any
//== such information.
//==========================================================================
//== Generated: 02/21/2025 10:50:21
//== Synopsys Memory Release: V04R31SZ_31JAN2021
//== 22fdsoi PDK 22FDX_V1.3_3.0
//==
//== IDTK_ROOT: /users/xcarril/scripts_22nm/in_gf22fdx_s1pRELV04R31SZ-Merge/idtk
//== IDDK_ROOT: /users/xcarril/scripts_22nm/in_gf22fdx_s1pRELV04R31SZ-Merge/iddk
//== IDDK_TECH: 22fdsoi
//==========================================================================


//==========================================================================
// Key parameters (exist only in the lower level *_memory_generic model inside of the verilog outer shell):
//
//  MSG_LVL  -- sets amount of messaging that appears in log.
//                0: least verbose,all erorr and warning messages are supressed
//                1: only prints 1st occurence of each errors
//                2: default, print 1st occurence of each error ,warning and informational message
//                3: most verbose, prints every occurence of the each error,warning and informational message
//
//  SKIP_POR -- enables memory operation when fuse inputs (MA margin adjust and RB / RW redundant steering) are 'x'.
//              - causes warning to be printed (fuse download simulation should be run to ensure these signals are initialized correctly).
//              - assigned to SKIP_POR_wire in case value needs to be forced/changed during simulation.
//
//  WL_FAIL* / BL_FAIL* / CELLx_FAIL* /CELL*FORCE_DATA -- used to inject fails into the memory during simulation.
//              - assigned to *_wire in case values need to be forced/changed during simulation.
//              - see parameter declaration section of *_memory_generic model for more details.
//
//  TESTCHIP  -- reserved for development use only (disables error messages related to T_STAB/T_WBT/MA when asserted, turns off DEEPSLEEP/POWERGATE sequence checking).
//                0: default
//
//  CLOCK_SEP -- used to adjust the amount of time that must be waited after one port's clock rising edge before a valid operation can be applied to the same address on the other port.
//               -only used if IVCS_RELAX_COLL_CHECK is defined.This is only used by true dual-port or two-port memories (like the SDP or R2P).
//                1: default value (1ns)
//
//  ROMDATA_FILE_NAME  -- this specifies the name of the file for initializing the ROM array.
//                        -accepts string for full path to file used to program the ROM.
//                        -supports ROM only
//                        -defaults to "NONE".
//
//  BINARY_FILE  -- this specifies whether the ROMDATA_FILE_NAME is in binary or hexadecimal format.
//                  -this is only used in ROM memories.
//                   1: Default.Indicates file is in binary format.
//                   0: Indicates file is in hex format.
//
//  PreloadArrayBinFile -- this specifies the name of the data file for intializing the memory array,data stored as binary data format in data file.
//                         -accepts string for full path to file used to program the memory.
//                         -Supports all the memories.
//                         -defaults to "NONE".
//
//  PreloadArrayHexFile -- this specifies the name of the data file for intializing the memory array,data stored as hexadecimal data format in data file.
//                         -accepts string for full path to file used to program the memory.
//                         -Supports all the memories.
//                         -defaults to "NONE".
//
//  Key defines:
//  ------------
//
//  IVCS_MSG_LVL     -- if defined this overrides the default MSG_LVL parameter.
//                      -this can be used to globally set a differnt MSG_LVL (See the MSG_LVL parameter description for more infomation on the allowed values ).
//
//  IVCS_PG          -- if defined enables power pins in design (VDD, VSS, VCS, VBN, VBP).
//                      -if this is defined at compile time these additional inout ports will be added to the memory.
//                      -they must be controlled to valid values (VDD=VCS=logical-1, VSS=logical-0) for the memory to function without error.
//
//  IVCS_INIT_MEM    -- if defined preloads memory with logical 0s when defined.
//                      -care should be taken to ensure the memory is initialized correctly at time 0 (otherwise the memory data will be corrupted and the pre-loaded value will be lost).
//                      -This is often used in conjunction with the SKIP_POR parameter.
//
//  IVCS_FAST_FUNC   -- if defined a "fast functional" memory model is enabled.
//                      -this model only supports functional operations (removes logic test, fail injection and redundancy modeling).
//                      -this model can be defined for faster simulations.
//
//  IVCS_CYCLE_SIM   -- if defined a simplified "synthesizable" memory model is enabled.
//                      -this is intended for use with most logic emulator based simulation flows.
//
//  IVCS_NO_SPEC_CHK -- if  defined then non-timing critical specify checks for DC test mode pins are disabled (e.g. T_LOGIC setup/hold or MA* setup/hold).
//
//  IVCS_MEM_T*      -- if defined various specparam values in specify statements in the shell can be overidden by globally defining new values.
//                        * IVCS_MEM_TXS  (input setup to clock rise)
//                        * IVCS_MEM_TXH  (input hold to clock rise)
//                        * IVCS_MEM_TCYC (minimum clock cycle time)
//                        * IVCS_MEM_TCKH (minimum clock high pulse width)
//                        * IVCS_MEM_TCKL (minimum clock low pulse width)
//                        * IVCS_MEM_TDSPGS (minimum CEN rise vs. Deep sleep / Powergate rise setup)
//                        * IVCS_MEM_TDSPGH (minimum Deep sleep / Powergate high pulse width)
//                        * IVCS_MEM_TPGH (minimum CEN fall vs. Powergate fall hold)
//                          --This value divided by IVCS_MEM_TCYC is used to generate the number of post powergate "wake up" cycles.  This number is used directly if IVCS_PGDS_DELAYCHK is asserted.
//                        * IVCS_MEM_TDSH (minimum CEN fall vs. Deep sleep fall hold)
//                          --This value divided by IVCS_MEM_TCYC is used to generate the number of post deep-sleep "wake up" cycles.  This number is used directly if IVCS_PGDS_DELAYCHK is asserted.
//                        * IVCS_MEM_TACC (minimum memory output access time)
//
//  IVCS_RELAX_COLL_CHECK -- if defined this relaxes some of the multi-port collision checking in any true dual-port or two-port memories (like the SDP or R2P).
//                           -it converts the default cycle-based checking to a time-based check.
//
//  IVCS_PGDS_DELAYCHK    -- if defined this overrides the normal checking of DEEPSLEEP/POWERGATE sequence checking (changes from counting clocked no-ops to just a CEN vs. DS/PG delay check)
//                           -this is only used in memories with DEEPSLEEP and/or POWERGATE inputs.
//                           -when using this mode is highly recommended that you set the following defines to an accurate/conservative value:
//                             --IVCS_MEM_TCYC to your slowest on chip cycle time (governs delay from CEN rise to entering a power mode)
//                             --IVCS_MEM_TPGH to the value recommended in the datasheet for your largest low power memory OR at least to 4x your cycle time (governs delay from exiting Powergate to when you can lower CEN)
//                             --IVCS_MEM_TDSH to the value recommended in the datasheet for your largest low power memory OR at least to 20x your cycle time (governs delay from exiting Deepsleep to when you can lower CEN)
//
//==========================================================================
`timescale 1ns / 1ps

`celldefine
  module IN22FDX_S1P_BFRG_W00320B032M08C128
    (
`ifdef IVCS_PG
     inout VDD,
     inout VCS,
     inout VBP,
     inout VBN,
     inout VSS,
`endif

     input CLK,
     input CEN,
     input RDWEN,
     input DEEPSLEEP,
     input POWERGATE,
     input  AS,
     input [4:0] AW,
     input [2:0] AC,
     input [31:0] D,
     input [31:0] BW,
     input T_BIST,
     input T_LOGIC,
     input T_CEN,
     input T_RDWEN,
     input T_DEEPSLEEP,
     input T_POWERGATE,
     input  T_AS,
     input [4:0] T_AW,
     input [2:0] T_AC,
     input [31:0] T_D,
     input [31:0] T_BW,
     input T_WBT,
     input T_STAB,
     input [1:0] MA_SAWL,
     input [1:0] MA_WL,
     input [1:0] MA_WRAS,
     input MA_WRASD,
     input  RBE,
     input [6:0] RBF0A,
     output  QRB,
     output [31:0] Q,
     output OBSV_CTL

     );

`ifndef IVCS_PG
 `ifdef IVCS_VCS_UPF_SIM
   wire VDD;
   wire VCS;
   wire VBN;
   wire VBP;
   wire VSS;
 `else
   wire VDD=1'b1;
   wire VCS=1'b1;
   wire VBN=1'b0;
   wire VBP=1'b0;
   wire VSS=1'b0;
 `endif
`endif

   wire [31:0] n_Q;
   wire [1:0] n_QRB;

   assign Q[31:0] = n_Q[31:0];
   assign QRB = n_QRB;

   //Notifier handling
   reg notifier_TCYC_CLK;
   reg notifier_TPW_CLK0;
   reg notifier_TPW_CLK1;
   reg notifier_TPW_DSPG1;
   reg notifier_TSH_CLK_AC;
   reg notifier_TSH_CLK_AS;
   reg notifier_TSH_CLK_AW;
   reg notifier_TSH_CLK_BW;
   reg notifier_TSH_CLK_CEN;
   reg notifier_TSH_CLK_D;
   reg notifier_TSH_CLK_MASAWL;
   reg notifier_TSH_CLK_MAWL;
   reg notifier_TSH_CLK_MAWRAS;
   reg notifier_TSH_CLK_MAWRASD;
   reg notifier_TSH_CLK_RBE;
   reg notifier_TSH_CLK_RBF0A;
   reg notifier_TSH_CLK_RBF1A;
   reg notifier_TSH_CLK_RDWEN;
   reg notifier_TSH_CLK_RWE;
   reg notifier_TSH_CLK_RWF0A;
   reg notifier_TSH_CLK_RWF1A;
   reg notifier_TSH_CLK_TAC;
   reg notifier_TSH_CLK_TAS;
   reg notifier_TSH_CLK_TAW;
   reg notifier_TSH_CLK_TBIST;
   reg notifier_TSH_CLK_TBW;
   reg notifier_TSH_CLK_TCEN;
   reg notifier_TSH_CLK_TD;
   reg notifier_TSH_CLK_TLOGIC;
   reg notifier_TSH_CLK_TRDWEN;
   reg notifier_TSH_CLK_TSTAB;
   reg notifier_TSH_CLK_TWBT;
   reg notifier_TS_DSPG;

`ifdef IVCS_CYCLE_SIM
   wire notifier = 1'b0;
`else
   reg notifier1;
   reg notifier2;
   reg notifier3;
   reg notifier4;
   reg notifier5;
   reg notifier;

   always @(   notifier_TCYC_CLK
            or notifier_TPW_CLK0
            or notifier_TPW_CLK1
            or notifier_TPW_DSPG1
            or notifier_TSH_CLK_CEN
            or notifier_TSH_CLK_MASAWL
            or notifier_TSH_CLK_MAWL
            or notifier_TSH_CLK_MAWRAS
            or notifier_TSH_CLK_MAWRASD
            or notifier_TSH_CLK_RBE
            or notifier_TSH_CLK_RBF0A
            or notifier_TSH_CLK_RBF1A
            or notifier_TSH_CLK_RWE
            or notifier_TSH_CLK_RWF0A
            or notifier_TSH_CLK_RWF1A
            or notifier_TSH_CLK_TBIST
            or notifier_TSH_CLK_TCEN
            or notifier_TSH_CLK_TLOGIC
            or notifier_TSH_CLK_TSTAB
            or notifier_TSH_CLK_TWBT
            or notifier_TS_DSPG
           )
     begin
        if(notifier1===1'b0) notifier1 = 1'b1;
        else                 notifier1 = 1'b0;
     end

   always @(   notifier_TSH_CLK_AC
            or notifier_TSH_CLK_AS
            or notifier_TSH_CLK_AW
            or notifier_TSH_CLK_RDWEN
           )
     begin
        // Don't fire this notifier if T_BIST=1 or CEN=1
        if(!((T_BIST===1'b1) || (CEN===1'b1))) begin
           if(notifier2===1'b0) notifier2 = 1'b1;
           else                 notifier2 = 1'b0;
        end
     end

   always @(   notifier_TSH_CLK_BW
            or notifier_TSH_CLK_D
           )
     begin
        // Don't fire this notifier if T_BIST=1 or CEN=1 or RDWEN=1
        if(!((T_BIST===1'b1) || (CEN===1'b1) || (RDWEN===1'b1))) begin
           if(notifier3===1'b0) notifier3 = 1'b1;
           else                 notifier3 = 1'b0;
        end
     end

   always @(   notifier_TSH_CLK_TAC
            or notifier_TSH_CLK_TAS
            or notifier_TSH_CLK_TAW
            or notifier_TSH_CLK_TRDWEN
           )
     begin
        // Don't fire this notifier if T_BIST=0 or T_CEN=1
        if(!((T_BIST===1'b0) || (T_CEN===1'b1))) begin
           if(notifier4===1'b0) notifier4 = 1'b1;
           else                 notifier4 = 1'b0;
        end
     end

   always @(   notifier_TSH_CLK_TBW
            or notifier_TSH_CLK_TD
           )
     begin
        // Don't fire this notifier if T_BIST=0 or T_CEN=1 or T_RDWEN=1
        if(!((T_BIST===1'b0) || (T_CEN===1'b1) || (T_RDWEN===1'b1))) begin
           if(notifier5===1'b0) notifier5 = 1'b1;
           else                 notifier5 = 1'b0;
        end
     end


   always @(notifier1 or notifier2 or notifier3 or notifier4 or notifier5) begin
      if(notifier===1'b0) notifier = 1'b1;
      else                notifier = 1'b0;
   end
`endif

`ifdef IVCS_MEM_TCYC
   localparam CYCLE_TIME = `IVCS_MEM_TCYC;
`else
   localparam CYCLE_TIME = 0.8;
`endif

`ifdef IVCS_MEM_TXS
   localparam SETUP_TIME = `IVCS_MEM_TXS;
`else
   localparam SETUP_TIME = 0.01;
`endif

`ifdef IVCS_MEM_TPGH
   localparam PG_TO_CEN  = `IVCS_MEM_TPGH;
`else
   localparam PG_TO_CEN  = 4.2;
`endif

`ifdef IVCS_MEM_TDSH
   localparam DS_TO_CEN  = `IVCS_MEM_TDSH;
`else
   localparam DS_TO_CEN  = 22.5;
`endif

   IN22FDX_S1P_BFRG_W00320B032M08C128_memory_generic
     #(
       .ALLOW_MA(1'b1),
       .NUM_SEG(1),
       .W_DEPTH(320),
       .AS_SIZE(1),
       .AW_SIZE(5),
       .AC_SIZE(3),
       .D_SIZE(32),
       .CYCLE_TIME(CYCLE_TIME),
       .SETUP_TIME(SETUP_TIME),
       .PG_TO_CEN(PG_TO_CEN),
       .DS_TO_CEN(DS_TO_CEN)
       )
   mem0
     (
      .VDD(VDD),
      .VCS(VCS),
      .VBN(VBN),
      .VBP(VBP),
      .VSS(VSS),
      .notifier(notifier),
      .clk(CLK),
      .cen(CEN),
      .rdwen(RDWEN),
      .deepsleep(DEEPSLEEP),
      .powergate(POWERGATE),
      .as(AS),
      .aw(AW[4:0]),
      .ac(AC[2:0]),
      .d(D[31:0]),
      .bw(BW[31:0]),
      .t_bist(T_BIST),
      .t_logic(T_LOGIC),
      .t_cen(T_CEN),
      .t_rdwen(T_RDWEN),
      .t_deepsleep(T_DEEPSLEEP),
      .t_powergate(T_POWERGATE),
      .t_as(T_AS),
      .t_aw(T_AW[4:0]),
      .t_ac(T_AC[2:0]),
      .t_d(T_D[31:0]),
      .t_bw(T_BW[31:0]),
      .pipeline(1'b0),
      .t_wbt(T_WBT),
      .t_stab(T_STAB),
      .ma_sawl(MA_SAWL[1:0]),
      .ma_wl(MA_WL[1:0]),
      .ma_wras(MA_WRAS[1:0]),
      .ma_wrasd(MA_WRASD),
      .rbe({1'b0, RBE}),
      .rbf1a(7'b000_0000),
      .rbf0a(RBF0A[6:0]),
      .rwe(2'b00),
      .rwf1a(8'b0000_0000),
      .rwf0a(8'b0000_0000),
      .qrb(n_QRB),
      .q(n_Q),
      .obsv_ctl(OBSV_CTL)
      );

   wire never;
   wire MASAWL1_MASAWL0   =  MA_SAWL[1] &  MA_SAWL[0];
   wire MASAWL1_NMASAWL0  =  MA_SAWL[1] & ~MA_SAWL[0];
   wire NMASAWL1_MASAWL0  = ~MA_SAWL[1] &  MA_SAWL[0];
   wire NMASAWL1_NMASAWL0 = ~MA_SAWL[1] & ~MA_SAWL[0];
   wire MASAWL1_MASAWL0_NMAWL1_NMAWL0   =  MA_SAWL[1] &  MA_SAWL[0] & ~MA_WL[1] & ~MA_WL[0];
   wire MASAWL1_NMASAWL0_NMAWL1_NMAWL0  =  MA_SAWL[1] & ~MA_SAWL[0] & ~MA_WL[1] & ~MA_WL[0];
   wire NMASAWL1_MASAWL0_NMAWL1_NMAWL0  = ~MA_SAWL[1] &  MA_SAWL[0] & ~MA_WL[1] & ~MA_WL[0];
   wire NMASAWL1_NMASAWL0_NMAWL1_NMAWL0 = ~MA_SAWL[1] & ~MA_SAWL[0] & ~MA_WL[1] & ~MA_WL[0];
   wire NMAWL1_MAWL0_MAWL1_NMAWL0_MAWL1_MAWL0 = (~MA_WL[1] & MA_WL[0]) | (MA_WL[1] & ~MA_WL[0]) | (MA_WL[1] & MA_WL[0]);
   wire NMASAWL1_NMASAWL0_MASAWL1_NMASAWL0_MASAWL1_MASAWL0 = (~MA_SAWL[1] & ~MA_SAWL[0]) | (MA_SAWL[1] & ~MA_SAWL[0]) | (MA_SAWL[1] & MA_SAWL[0]);
   wire NTBIST         = ~T_BIST;
   wire NTBIST_NTLOGIC = ~T_BIST & ~T_LOGIC;
   wire TBIST_NTLOGIC  =  T_BIST & ~T_LOGIC;

`ifdef IVCS_NO_SPEC_CHK
   //Define to turn off non-timing critical checks for typically asynchronous paths
   assign never = 0;
`else
   assign never = 1;
`endif

   specify

`ifdef IVCS_MEM_TCYC
      specparam tcyc_CLK          = `IVCS_MEM_TCYC;
`else
      specparam tcyc_CLK          = 0.8;
`endif

`ifdef IVCS_MEM_TACC
      specparam tdelay_CLK_X_01   = `IVCS_MEM_TACC;
      specparam tdelay_CLK_X_10   = `IVCS_MEM_TACC;
`else
      specparam tdelay_CLK_X_01   = 0.1;
      specparam tdelay_CLK_X_10   = 0.1;
`endif

`ifdef IVCS_MEM_TPROP
      specparam tdelay_PROP_X_01  = `IVCS_MEM_TPROP;
      specparam tdelay_PROP_X_10  = `IVCS_MEM_TPROP;
`else
      specparam tdelay_PROP_X_01  = 0.1;
      specparam tdelay_PROP_X_10  = 0.1;
`endif

`ifdef IVCS_MEM_TCKL
      specparam tpw_CLK_0         = `IVCS_MEM_TCKL;
`else
      specparam tpw_CLK_0         = 0.1;
`endif

`ifdef IVCS_MEM_TCKH
      specparam tpw_CLK_1         = `IVCS_MEM_TCKH;
`else
      specparam tpw_CLK_1         = 0.1;
`endif

`ifdef IVCS_MEM_TXS
      specparam tsetup_X_CLK      = `IVCS_MEM_TXS;
`else
      specparam tsetup_X_CLK      = 0.01;
`endif

`ifdef IVCS_MEM_TXH
      specparam thold_X_CLK       = `IVCS_MEM_TXH;
`else
      specparam thold_X_CLK       = 0.0;
`endif

`ifdef IVCS_MEM_TDSPGH
      specparam tpw_DSPG_1        = `IVCS_MEM_TDSPGH;
`else
      specparam tpw_DSPG_1        = 1.9;
`endif

`ifdef IVCS_MEM_TDSPGS
      specparam tsetup_DSPG       = `IVCS_MEM_TDSPGS;
`else
      specparam tsetup_DSPG       = 1.0;
`endif

`ifdef IVCS_MEM_TPGH
      specparam thold_PG          = `IVCS_MEM_TPGH;
`else
      specparam thold_PG          = 4.2;
`endif

`ifdef IVCS_MEM_TDSH
      specparam thold_DS          = `IVCS_MEM_TDSH;
`else
      specparam thold_DS          = 22.5;
`endif

      $period(posedge CLK &&& MASAWL1_MASAWL0_NMAWL1_NMAWL0        , tcyc_CLK, notifier_TCYC_CLK);
      $period(posedge CLK &&& MASAWL1_NMASAWL0_NMAWL1_NMAWL0       , tcyc_CLK, notifier_TCYC_CLK);
      $period(posedge CLK &&& NMASAWL1_MASAWL0_NMAWL1_NMAWL0       , tcyc_CLK, notifier_TCYC_CLK);
      $period(posedge CLK &&& NMASAWL1_NMASAWL0_NMAWL1_NMAWL0      , tcyc_CLK, notifier_TCYC_CLK);
      $period(posedge CLK &&& NMAWL1_MAWL0_MAWL1_NMAWL0_MAWL1_MAWL0, tcyc_CLK, notifier_TCYC_CLK);

      $width(posedge CLK, tpw_CLK_1, 0, notifier_TPW_CLK1);
      $width(negedge CLK, tpw_CLK_0, 0, notifier_TPW_CLK0);
      $width(posedge DEEPSLEEP &&& NTBIST_NTLOGIC, tpw_DSPG_1, 0, notifier_TPW_DSPG1);
      $width(posedge POWERGATE &&& NTBIST_NTLOGIC, tpw_DSPG_1, 0, notifier_TPW_DSPG1);
      $width(posedge T_DEEPSLEEP &&& TBIST_NTLOGIC, tpw_DSPG_1, 0, notifier_TPW_DSPG1);
      $width(posedge T_POWERGATE &&& TBIST_NTLOGIC, tpw_DSPG_1, 0, notifier_TPW_DSPG1);

      $setup (posedge CEN  , posedge DEEPSLEEP  &&& NTBIST_NTLOGIC, tsetup_DSPG,  notifier_TS_DSPG);
      $setup (posedge CEN  , posedge POWERGATE  &&& NTBIST_NTLOGIC, tsetup_DSPG,  notifier_TS_DSPG);
      $setup (posedge T_CEN, posedge T_DEEPSLEEP &&& TBIST_NTLOGIC, tsetup_DSPG,  notifier_TS_DSPG);
      $setup (posedge T_CEN, posedge T_POWERGATE &&& TBIST_NTLOGIC, tsetup_DSPG,  notifier_TS_DSPG);
      $hold (negedge DEEPSLEEP &&& NTBIST_NTLOGIC,negedge CEN, thold_DS,  notifier_TS_DSPG);
      $hold (negedge POWERGATE &&& NTBIST_NTLOGIC,negedge CEN, thold_PG,  notifier_TS_DSPG);
      $hold (negedge T_DEEPSLEEP &&& TBIST_NTLOGIC,negedge T_CEN, thold_DS,  notifier_TS_DSPG);
      $hold (negedge T_POWERGATE &&& TBIST_NTLOGIC,negedge T_CEN, thold_PG,  notifier_TS_DSPG);

      $setuphold (posedge CLK &&& NTBIST, posedge CEN, tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_CEN);
      $setuphold (posedge CLK &&& NTBIST, negedge CEN, tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_CEN);
      $setuphold (posedge CLK &&& NTBIST, posedge RDWEN, tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_RDWEN);
      $setuphold (posedge CLK &&& NTBIST, negedge RDWEN, tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_RDWEN);
      $setuphold (posedge CLK &&& NTBIST, posedge AS, tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_AS);
      $setuphold (posedge CLK &&& NTBIST, negedge AS, tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_AS);
      $setuphold (posedge CLK &&& NTBIST, posedge AW[4], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_AW);
      $setuphold (posedge CLK &&& NTBIST, posedge AW[3], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_AW);
      $setuphold (posedge CLK &&& NTBIST, posedge AW[2], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_AW);
      $setuphold (posedge CLK &&& NTBIST, posedge AW[1], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_AW);
      $setuphold (posedge CLK &&& NTBIST, posedge AW[0], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_AW);
      $setuphold (posedge CLK &&& NTBIST, negedge AW[4], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_AW);
      $setuphold (posedge CLK &&& NTBIST, negedge AW[3], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_AW);
      $setuphold (posedge CLK &&& NTBIST, negedge AW[2], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_AW);
      $setuphold (posedge CLK &&& NTBIST, negedge AW[1], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_AW);
      $setuphold (posedge CLK &&& NTBIST, negedge AW[0], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_AW);
      $setuphold (posedge CLK &&& NTBIST, posedge AC[2], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_AC);
      $setuphold (posedge CLK &&& NTBIST, posedge AC[1], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_AC);
      $setuphold (posedge CLK &&& NTBIST, posedge AC[0], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_AC);
      $setuphold (posedge CLK &&& NTBIST, negedge AC[2], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_AC);
      $setuphold (posedge CLK &&& NTBIST, negedge AC[1], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_AC);
      $setuphold (posedge CLK &&& NTBIST, negedge AC[0], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_AC);
      $setuphold (posedge CLK &&& NTBIST, posedge D[31], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_D);
      $setuphold (posedge CLK &&& NTBIST, posedge D[30], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_D);
      $setuphold (posedge CLK &&& NTBIST, posedge D[29], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_D);
      $setuphold (posedge CLK &&& NTBIST, posedge D[28], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_D);
      $setuphold (posedge CLK &&& NTBIST, posedge D[27], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_D);
      $setuphold (posedge CLK &&& NTBIST, posedge D[26], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_D);
      $setuphold (posedge CLK &&& NTBIST, posedge D[25], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_D);
      $setuphold (posedge CLK &&& NTBIST, posedge D[24], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_D);
      $setuphold (posedge CLK &&& NTBIST, posedge D[23], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_D);
      $setuphold (posedge CLK &&& NTBIST, posedge D[22], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_D);
      $setuphold (posedge CLK &&& NTBIST, posedge D[21], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_D);
      $setuphold (posedge CLK &&& NTBIST, posedge D[20], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_D);
      $setuphold (posedge CLK &&& NTBIST, posedge D[19], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_D);
      $setuphold (posedge CLK &&& NTBIST, posedge D[18], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_D);
      $setuphold (posedge CLK &&& NTBIST, posedge D[17], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_D);
      $setuphold (posedge CLK &&& NTBIST, posedge D[16], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_D);
      $setuphold (posedge CLK &&& NTBIST, posedge D[15], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_D);
      $setuphold (posedge CLK &&& NTBIST, posedge D[14], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_D);
      $setuphold (posedge CLK &&& NTBIST, posedge D[13], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_D);
      $setuphold (posedge CLK &&& NTBIST, posedge D[12], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_D);
      $setuphold (posedge CLK &&& NTBIST, posedge D[11], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_D);
      $setuphold (posedge CLK &&& NTBIST, posedge D[10], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_D);
      $setuphold (posedge CLK &&& NTBIST, posedge D[9], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_D);
      $setuphold (posedge CLK &&& NTBIST, posedge D[8], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_D);
      $setuphold (posedge CLK &&& NTBIST, posedge D[7], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_D);
      $setuphold (posedge CLK &&& NTBIST, posedge D[6], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_D);
      $setuphold (posedge CLK &&& NTBIST, posedge D[5], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_D);
      $setuphold (posedge CLK &&& NTBIST, posedge D[4], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_D);
      $setuphold (posedge CLK &&& NTBIST, posedge D[3], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_D);
      $setuphold (posedge CLK &&& NTBIST, posedge D[2], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_D);
      $setuphold (posedge CLK &&& NTBIST, posedge D[1], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_D);
      $setuphold (posedge CLK &&& NTBIST, posedge D[0], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_D);
      $setuphold (posedge CLK &&& NTBIST, negedge D[31], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_D);
      $setuphold (posedge CLK &&& NTBIST, negedge D[30], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_D);
      $setuphold (posedge CLK &&& NTBIST, negedge D[29], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_D);
      $setuphold (posedge CLK &&& NTBIST, negedge D[28], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_D);
      $setuphold (posedge CLK &&& NTBIST, negedge D[27], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_D);
      $setuphold (posedge CLK &&& NTBIST, negedge D[26], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_D);
      $setuphold (posedge CLK &&& NTBIST, negedge D[25], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_D);
      $setuphold (posedge CLK &&& NTBIST, negedge D[24], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_D);
      $setuphold (posedge CLK &&& NTBIST, negedge D[23], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_D);
      $setuphold (posedge CLK &&& NTBIST, negedge D[22], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_D);
      $setuphold (posedge CLK &&& NTBIST, negedge D[21], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_D);
      $setuphold (posedge CLK &&& NTBIST, negedge D[20], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_D);
      $setuphold (posedge CLK &&& NTBIST, negedge D[19], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_D);
      $setuphold (posedge CLK &&& NTBIST, negedge D[18], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_D);
      $setuphold (posedge CLK &&& NTBIST, negedge D[17], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_D);
      $setuphold (posedge CLK &&& NTBIST, negedge D[16], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_D);
      $setuphold (posedge CLK &&& NTBIST, negedge D[15], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_D);
      $setuphold (posedge CLK &&& NTBIST, negedge D[14], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_D);
      $setuphold (posedge CLK &&& NTBIST, negedge D[13], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_D);
      $setuphold (posedge CLK &&& NTBIST, negedge D[12], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_D);
      $setuphold (posedge CLK &&& NTBIST, negedge D[11], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_D);
      $setuphold (posedge CLK &&& NTBIST, negedge D[10], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_D);
      $setuphold (posedge CLK &&& NTBIST, negedge D[9], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_D);
      $setuphold (posedge CLK &&& NTBIST, negedge D[8], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_D);
      $setuphold (posedge CLK &&& NTBIST, negedge D[7], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_D);
      $setuphold (posedge CLK &&& NTBIST, negedge D[6], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_D);
      $setuphold (posedge CLK &&& NTBIST, negedge D[5], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_D);
      $setuphold (posedge CLK &&& NTBIST, negedge D[4], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_D);
      $setuphold (posedge CLK &&& NTBIST, negedge D[3], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_D);
      $setuphold (posedge CLK &&& NTBIST, negedge D[2], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_D);
      $setuphold (posedge CLK &&& NTBIST, negedge D[1], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_D);
      $setuphold (posedge CLK &&& NTBIST, negedge D[0], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_D);
      $setuphold (posedge CLK &&& NTBIST, posedge BW[31], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_BW);
      $setuphold (posedge CLK &&& NTBIST, posedge BW[30], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_BW);
      $setuphold (posedge CLK &&& NTBIST, posedge BW[29], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_BW);
      $setuphold (posedge CLK &&& NTBIST, posedge BW[28], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_BW);
      $setuphold (posedge CLK &&& NTBIST, posedge BW[27], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_BW);
      $setuphold (posedge CLK &&& NTBIST, posedge BW[26], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_BW);
      $setuphold (posedge CLK &&& NTBIST, posedge BW[25], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_BW);
      $setuphold (posedge CLK &&& NTBIST, posedge BW[24], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_BW);
      $setuphold (posedge CLK &&& NTBIST, posedge BW[23], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_BW);
      $setuphold (posedge CLK &&& NTBIST, posedge BW[22], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_BW);
      $setuphold (posedge CLK &&& NTBIST, posedge BW[21], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_BW);
      $setuphold (posedge CLK &&& NTBIST, posedge BW[20], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_BW);
      $setuphold (posedge CLK &&& NTBIST, posedge BW[19], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_BW);
      $setuphold (posedge CLK &&& NTBIST, posedge BW[18], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_BW);
      $setuphold (posedge CLK &&& NTBIST, posedge BW[17], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_BW);
      $setuphold (posedge CLK &&& NTBIST, posedge BW[16], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_BW);
      $setuphold (posedge CLK &&& NTBIST, posedge BW[15], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_BW);
      $setuphold (posedge CLK &&& NTBIST, posedge BW[14], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_BW);
      $setuphold (posedge CLK &&& NTBIST, posedge BW[13], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_BW);
      $setuphold (posedge CLK &&& NTBIST, posedge BW[12], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_BW);
      $setuphold (posedge CLK &&& NTBIST, posedge BW[11], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_BW);
      $setuphold (posedge CLK &&& NTBIST, posedge BW[10], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_BW);
      $setuphold (posedge CLK &&& NTBIST, posedge BW[9], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_BW);
      $setuphold (posedge CLK &&& NTBIST, posedge BW[8], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_BW);
      $setuphold (posedge CLK &&& NTBIST, posedge BW[7], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_BW);
      $setuphold (posedge CLK &&& NTBIST, posedge BW[6], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_BW);
      $setuphold (posedge CLK &&& NTBIST, posedge BW[5], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_BW);
      $setuphold (posedge CLK &&& NTBIST, posedge BW[4], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_BW);
      $setuphold (posedge CLK &&& NTBIST, posedge BW[3], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_BW);
      $setuphold (posedge CLK &&& NTBIST, posedge BW[2], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_BW);
      $setuphold (posedge CLK &&& NTBIST, posedge BW[1], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_BW);
      $setuphold (posedge CLK &&& NTBIST, posedge BW[0], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_BW);
      $setuphold (posedge CLK &&& NTBIST, negedge BW[31], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_BW);
      $setuphold (posedge CLK &&& NTBIST, negedge BW[30], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_BW);
      $setuphold (posedge CLK &&& NTBIST, negedge BW[29], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_BW);
      $setuphold (posedge CLK &&& NTBIST, negedge BW[28], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_BW);
      $setuphold (posedge CLK &&& NTBIST, negedge BW[27], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_BW);
      $setuphold (posedge CLK &&& NTBIST, negedge BW[26], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_BW);
      $setuphold (posedge CLK &&& NTBIST, negedge BW[25], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_BW);
      $setuphold (posedge CLK &&& NTBIST, negedge BW[24], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_BW);
      $setuphold (posedge CLK &&& NTBIST, negedge BW[23], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_BW);
      $setuphold (posedge CLK &&& NTBIST, negedge BW[22], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_BW);
      $setuphold (posedge CLK &&& NTBIST, negedge BW[21], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_BW);
      $setuphold (posedge CLK &&& NTBIST, negedge BW[20], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_BW);
      $setuphold (posedge CLK &&& NTBIST, negedge BW[19], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_BW);
      $setuphold (posedge CLK &&& NTBIST, negedge BW[18], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_BW);
      $setuphold (posedge CLK &&& NTBIST, negedge BW[17], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_BW);
      $setuphold (posedge CLK &&& NTBIST, negedge BW[16], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_BW);
      $setuphold (posedge CLK &&& NTBIST, negedge BW[15], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_BW);
      $setuphold (posedge CLK &&& NTBIST, negedge BW[14], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_BW);
      $setuphold (posedge CLK &&& NTBIST, negedge BW[13], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_BW);
      $setuphold (posedge CLK &&& NTBIST, negedge BW[12], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_BW);
      $setuphold (posedge CLK &&& NTBIST, negedge BW[11], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_BW);
      $setuphold (posedge CLK &&& NTBIST, negedge BW[10], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_BW);
      $setuphold (posedge CLK &&& NTBIST, negedge BW[9], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_BW);
      $setuphold (posedge CLK &&& NTBIST, negedge BW[8], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_BW);
      $setuphold (posedge CLK &&& NTBIST, negedge BW[7], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_BW);
      $setuphold (posedge CLK &&& NTBIST, negedge BW[6], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_BW);
      $setuphold (posedge CLK &&& NTBIST, negedge BW[5], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_BW);
      $setuphold (posedge CLK &&& NTBIST, negedge BW[4], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_BW);
      $setuphold (posedge CLK &&& NTBIST, negedge BW[3], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_BW);
      $setuphold (posedge CLK &&& NTBIST, negedge BW[2], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_BW);
      $setuphold (posedge CLK &&& NTBIST, negedge BW[1], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_BW);
      $setuphold (posedge CLK &&& NTBIST, negedge BW[0], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_BW);
      $setuphold (posedge CLK &&& never, posedge T_BIST, tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TBIST);
      $setuphold (posedge CLK &&& never, negedge T_BIST, tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TBIST);
      $setuphold (posedge CLK &&& never, posedge T_LOGIC, tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TLOGIC);
      $setuphold (posedge CLK &&& never, negedge T_LOGIC, tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TLOGIC);
      $setuphold (posedge CLK &&& T_BIST, posedge T_CEN, tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TCEN);
      $setuphold (posedge CLK &&& T_BIST, negedge T_CEN, tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TCEN);
      $setuphold (posedge CLK &&& T_BIST, posedge T_RDWEN, tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TRDWEN);
      $setuphold (posedge CLK &&& T_BIST, negedge T_RDWEN, tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TRDWEN);
      $setuphold (posedge CLK &&& T_BIST, posedge T_AS, tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TAS);
      $setuphold (posedge CLK &&& T_BIST, negedge T_AS, tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TAS);
      $setuphold (posedge CLK &&& T_BIST, posedge T_AW[4], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TAW);
      $setuphold (posedge CLK &&& T_BIST, posedge T_AW[3], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TAW);
      $setuphold (posedge CLK &&& T_BIST, posedge T_AW[2], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TAW);
      $setuphold (posedge CLK &&& T_BIST, posedge T_AW[1], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TAW);
      $setuphold (posedge CLK &&& T_BIST, posedge T_AW[0], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TAW);
      $setuphold (posedge CLK &&& T_BIST, negedge T_AW[4], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TAW);
      $setuphold (posedge CLK &&& T_BIST, negedge T_AW[3], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TAW);
      $setuphold (posedge CLK &&& T_BIST, negedge T_AW[2], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TAW);
      $setuphold (posedge CLK &&& T_BIST, negedge T_AW[1], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TAW);
      $setuphold (posedge CLK &&& T_BIST, negedge T_AW[0], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TAW);
      $setuphold (posedge CLK &&& T_BIST, posedge T_AC[2], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TAC);
      $setuphold (posedge CLK &&& T_BIST, posedge T_AC[1], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TAC);
      $setuphold (posedge CLK &&& T_BIST, posedge T_AC[0], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TAC);
      $setuphold (posedge CLK &&& T_BIST, negedge T_AC[2], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TAC);
      $setuphold (posedge CLK &&& T_BIST, negedge T_AC[1], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TAC);
      $setuphold (posedge CLK &&& T_BIST, negedge T_AC[0], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TAC);
      $setuphold (posedge CLK &&& T_BIST, posedge T_D[31], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TD);
      $setuphold (posedge CLK &&& T_BIST, posedge T_D[30], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TD);
      $setuphold (posedge CLK &&& T_BIST, posedge T_D[29], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TD);
      $setuphold (posedge CLK &&& T_BIST, posedge T_D[28], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TD);
      $setuphold (posedge CLK &&& T_BIST, posedge T_D[27], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TD);
      $setuphold (posedge CLK &&& T_BIST, posedge T_D[26], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TD);
      $setuphold (posedge CLK &&& T_BIST, posedge T_D[25], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TD);
      $setuphold (posedge CLK &&& T_BIST, posedge T_D[24], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TD);
      $setuphold (posedge CLK &&& T_BIST, posedge T_D[23], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TD);
      $setuphold (posedge CLK &&& T_BIST, posedge T_D[22], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TD);
      $setuphold (posedge CLK &&& T_BIST, posedge T_D[21], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TD);
      $setuphold (posedge CLK &&& T_BIST, posedge T_D[20], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TD);
      $setuphold (posedge CLK &&& T_BIST, posedge T_D[19], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TD);
      $setuphold (posedge CLK &&& T_BIST, posedge T_D[18], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TD);
      $setuphold (posedge CLK &&& T_BIST, posedge T_D[17], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TD);
      $setuphold (posedge CLK &&& T_BIST, posedge T_D[16], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TD);
      $setuphold (posedge CLK &&& T_BIST, posedge T_D[15], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TD);
      $setuphold (posedge CLK &&& T_BIST, posedge T_D[14], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TD);
      $setuphold (posedge CLK &&& T_BIST, posedge T_D[13], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TD);
      $setuphold (posedge CLK &&& T_BIST, posedge T_D[12], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TD);
      $setuphold (posedge CLK &&& T_BIST, posedge T_D[11], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TD);
      $setuphold (posedge CLK &&& T_BIST, posedge T_D[10], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TD);
      $setuphold (posedge CLK &&& T_BIST, posedge T_D[9], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TD);
      $setuphold (posedge CLK &&& T_BIST, posedge T_D[8], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TD);
      $setuphold (posedge CLK &&& T_BIST, posedge T_D[7], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TD);
      $setuphold (posedge CLK &&& T_BIST, posedge T_D[6], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TD);
      $setuphold (posedge CLK &&& T_BIST, posedge T_D[5], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TD);
      $setuphold (posedge CLK &&& T_BIST, posedge T_D[4], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TD);
      $setuphold (posedge CLK &&& T_BIST, posedge T_D[3], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TD);
      $setuphold (posedge CLK &&& T_BIST, posedge T_D[2], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TD);
      $setuphold (posedge CLK &&& T_BIST, posedge T_D[1], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TD);
      $setuphold (posedge CLK &&& T_BIST, posedge T_D[0], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TD);
      $setuphold (posedge CLK &&& T_BIST, negedge T_D[31], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TD);
      $setuphold (posedge CLK &&& T_BIST, negedge T_D[30], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TD);
      $setuphold (posedge CLK &&& T_BIST, negedge T_D[29], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TD);
      $setuphold (posedge CLK &&& T_BIST, negedge T_D[28], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TD);
      $setuphold (posedge CLK &&& T_BIST, negedge T_D[27], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TD);
      $setuphold (posedge CLK &&& T_BIST, negedge T_D[26], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TD);
      $setuphold (posedge CLK &&& T_BIST, negedge T_D[25], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TD);
      $setuphold (posedge CLK &&& T_BIST, negedge T_D[24], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TD);
      $setuphold (posedge CLK &&& T_BIST, negedge T_D[23], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TD);
      $setuphold (posedge CLK &&& T_BIST, negedge T_D[22], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TD);
      $setuphold (posedge CLK &&& T_BIST, negedge T_D[21], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TD);
      $setuphold (posedge CLK &&& T_BIST, negedge T_D[20], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TD);
      $setuphold (posedge CLK &&& T_BIST, negedge T_D[19], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TD);
      $setuphold (posedge CLK &&& T_BIST, negedge T_D[18], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TD);
      $setuphold (posedge CLK &&& T_BIST, negedge T_D[17], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TD);
      $setuphold (posedge CLK &&& T_BIST, negedge T_D[16], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TD);
      $setuphold (posedge CLK &&& T_BIST, negedge T_D[15], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TD);
      $setuphold (posedge CLK &&& T_BIST, negedge T_D[14], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TD);
      $setuphold (posedge CLK &&& T_BIST, negedge T_D[13], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TD);
      $setuphold (posedge CLK &&& T_BIST, negedge T_D[12], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TD);
      $setuphold (posedge CLK &&& T_BIST, negedge T_D[11], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TD);
      $setuphold (posedge CLK &&& T_BIST, negedge T_D[10], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TD);
      $setuphold (posedge CLK &&& T_BIST, negedge T_D[9], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TD);
      $setuphold (posedge CLK &&& T_BIST, negedge T_D[8], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TD);
      $setuphold (posedge CLK &&& T_BIST, negedge T_D[7], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TD);
      $setuphold (posedge CLK &&& T_BIST, negedge T_D[6], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TD);
      $setuphold (posedge CLK &&& T_BIST, negedge T_D[5], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TD);
      $setuphold (posedge CLK &&& T_BIST, negedge T_D[4], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TD);
      $setuphold (posedge CLK &&& T_BIST, negedge T_D[3], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TD);
      $setuphold (posedge CLK &&& T_BIST, negedge T_D[2], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TD);
      $setuphold (posedge CLK &&& T_BIST, negedge T_D[1], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TD);
      $setuphold (posedge CLK &&& T_BIST, negedge T_D[0], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TD);
      $setuphold (posedge CLK &&& T_BIST, posedge T_BW[31], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TBW);
      $setuphold (posedge CLK &&& T_BIST, posedge T_BW[30], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TBW);
      $setuphold (posedge CLK &&& T_BIST, posedge T_BW[29], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TBW);
      $setuphold (posedge CLK &&& T_BIST, posedge T_BW[28], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TBW);
      $setuphold (posedge CLK &&& T_BIST, posedge T_BW[27], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TBW);
      $setuphold (posedge CLK &&& T_BIST, posedge T_BW[26], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TBW);
      $setuphold (posedge CLK &&& T_BIST, posedge T_BW[25], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TBW);
      $setuphold (posedge CLK &&& T_BIST, posedge T_BW[24], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TBW);
      $setuphold (posedge CLK &&& T_BIST, posedge T_BW[23], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TBW);
      $setuphold (posedge CLK &&& T_BIST, posedge T_BW[22], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TBW);
      $setuphold (posedge CLK &&& T_BIST, posedge T_BW[21], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TBW);
      $setuphold (posedge CLK &&& T_BIST, posedge T_BW[20], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TBW);
      $setuphold (posedge CLK &&& T_BIST, posedge T_BW[19], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TBW);
      $setuphold (posedge CLK &&& T_BIST, posedge T_BW[18], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TBW);
      $setuphold (posedge CLK &&& T_BIST, posedge T_BW[17], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TBW);
      $setuphold (posedge CLK &&& T_BIST, posedge T_BW[16], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TBW);
      $setuphold (posedge CLK &&& T_BIST, posedge T_BW[15], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TBW);
      $setuphold (posedge CLK &&& T_BIST, posedge T_BW[14], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TBW);
      $setuphold (posedge CLK &&& T_BIST, posedge T_BW[13], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TBW);
      $setuphold (posedge CLK &&& T_BIST, posedge T_BW[12], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TBW);
      $setuphold (posedge CLK &&& T_BIST, posedge T_BW[11], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TBW);
      $setuphold (posedge CLK &&& T_BIST, posedge T_BW[10], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TBW);
      $setuphold (posedge CLK &&& T_BIST, posedge T_BW[9], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TBW);
      $setuphold (posedge CLK &&& T_BIST, posedge T_BW[8], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TBW);
      $setuphold (posedge CLK &&& T_BIST, posedge T_BW[7], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TBW);
      $setuphold (posedge CLK &&& T_BIST, posedge T_BW[6], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TBW);
      $setuphold (posedge CLK &&& T_BIST, posedge T_BW[5], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TBW);
      $setuphold (posedge CLK &&& T_BIST, posedge T_BW[4], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TBW);
      $setuphold (posedge CLK &&& T_BIST, posedge T_BW[3], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TBW);
      $setuphold (posedge CLK &&& T_BIST, posedge T_BW[2], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TBW);
      $setuphold (posedge CLK &&& T_BIST, posedge T_BW[1], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TBW);
      $setuphold (posedge CLK &&& T_BIST, posedge T_BW[0], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TBW);
      $setuphold (posedge CLK &&& T_BIST, negedge T_BW[31], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TBW);
      $setuphold (posedge CLK &&& T_BIST, negedge T_BW[30], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TBW);
      $setuphold (posedge CLK &&& T_BIST, negedge T_BW[29], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TBW);
      $setuphold (posedge CLK &&& T_BIST, negedge T_BW[28], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TBW);
      $setuphold (posedge CLK &&& T_BIST, negedge T_BW[27], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TBW);
      $setuphold (posedge CLK &&& T_BIST, negedge T_BW[26], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TBW);
      $setuphold (posedge CLK &&& T_BIST, negedge T_BW[25], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TBW);
      $setuphold (posedge CLK &&& T_BIST, negedge T_BW[24], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TBW);
      $setuphold (posedge CLK &&& T_BIST, negedge T_BW[23], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TBW);
      $setuphold (posedge CLK &&& T_BIST, negedge T_BW[22], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TBW);
      $setuphold (posedge CLK &&& T_BIST, negedge T_BW[21], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TBW);
      $setuphold (posedge CLK &&& T_BIST, negedge T_BW[20], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TBW);
      $setuphold (posedge CLK &&& T_BIST, negedge T_BW[19], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TBW);
      $setuphold (posedge CLK &&& T_BIST, negedge T_BW[18], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TBW);
      $setuphold (posedge CLK &&& T_BIST, negedge T_BW[17], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TBW);
      $setuphold (posedge CLK &&& T_BIST, negedge T_BW[16], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TBW);
      $setuphold (posedge CLK &&& T_BIST, negedge T_BW[15], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TBW);
      $setuphold (posedge CLK &&& T_BIST, negedge T_BW[14], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TBW);
      $setuphold (posedge CLK &&& T_BIST, negedge T_BW[13], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TBW);
      $setuphold (posedge CLK &&& T_BIST, negedge T_BW[12], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TBW);
      $setuphold (posedge CLK &&& T_BIST, negedge T_BW[11], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TBW);
      $setuphold (posedge CLK &&& T_BIST, negedge T_BW[10], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TBW);
      $setuphold (posedge CLK &&& T_BIST, negedge T_BW[9], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TBW);
      $setuphold (posedge CLK &&& T_BIST, negedge T_BW[8], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TBW);
      $setuphold (posedge CLK &&& T_BIST, negedge T_BW[7], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TBW);
      $setuphold (posedge CLK &&& T_BIST, negedge T_BW[6], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TBW);
      $setuphold (posedge CLK &&& T_BIST, negedge T_BW[5], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TBW);
      $setuphold (posedge CLK &&& T_BIST, negedge T_BW[4], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TBW);
      $setuphold (posedge CLK &&& T_BIST, negedge T_BW[3], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TBW);
      $setuphold (posedge CLK &&& T_BIST, negedge T_BW[2], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TBW);
      $setuphold (posedge CLK &&& T_BIST, negedge T_BW[1], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TBW);
      $setuphold (posedge CLK &&& T_BIST, negedge T_BW[0], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TBW);
      $setuphold (posedge CLK &&& never, posedge T_WBT, tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TWBT);
      $setuphold (posedge CLK &&& never, negedge T_WBT, tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TWBT);
      $setuphold (posedge CLK &&& never, posedge T_STAB, tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TSTAB);
      $setuphold (posedge CLK &&& never, negedge T_STAB, tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_TSTAB);
      $setuphold (posedge CLK &&& never, posedge MA_SAWL[1], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_MASAWL);
      $setuphold (posedge CLK &&& never, posedge MA_SAWL[0], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_MASAWL);
      $setuphold (posedge CLK &&& never, negedge MA_SAWL[1], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_MASAWL);
      $setuphold (posedge CLK &&& never, negedge MA_SAWL[0], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_MASAWL);
      $setuphold (posedge CLK &&& never, posedge MA_WL[1], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_MAWL);
      $setuphold (posedge CLK &&& never, posedge MA_WL[0], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_MAWL);
      $setuphold (posedge CLK &&& never, negedge MA_WL[1], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_MAWL);
      $setuphold (posedge CLK &&& never, negedge MA_WL[0], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_MAWL);
      $setuphold (posedge CLK &&& never, posedge MA_WRAS[1], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_MAWRAS);
      $setuphold (posedge CLK &&& never, posedge MA_WRAS[0], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_MAWRAS);
      $setuphold (posedge CLK &&& never, negedge MA_WRAS[1], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_MAWRAS);
      $setuphold (posedge CLK &&& never, negedge MA_WRAS[0], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_MAWRAS);
      $setuphold (posedge CLK &&& never, posedge MA_WRASD, tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_MAWRASD);
      $setuphold (posedge CLK &&& never, negedge MA_WRASD, tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_MAWRASD);
      $setuphold (posedge CLK &&& never, posedge RBE, tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_RBE);
      $setuphold (posedge CLK &&& never, negedge RBE, tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_RBE);
      $setuphold (posedge CLK &&& never, posedge RBF0A[6], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_RBF0A);
      $setuphold (posedge CLK &&& never, posedge RBF0A[5], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_RBF0A);
      $setuphold (posedge CLK &&& never, posedge RBF0A[4], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_RBF0A);
      $setuphold (posedge CLK &&& never, posedge RBF0A[3], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_RBF0A);
      $setuphold (posedge CLK &&& never, posedge RBF0A[2], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_RBF0A);
      $setuphold (posedge CLK &&& never, posedge RBF0A[1], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_RBF0A);
      $setuphold (posedge CLK &&& never, posedge RBF0A[0], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_RBF0A);
      $setuphold (posedge CLK &&& never, negedge RBF0A[6], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_RBF0A);
      $setuphold (posedge CLK &&& never, negedge RBF0A[5], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_RBF0A);
      $setuphold (posedge CLK &&& never, negedge RBF0A[4], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_RBF0A);
      $setuphold (posedge CLK &&& never, negedge RBF0A[3], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_RBF0A);
      $setuphold (posedge CLK &&& never, negedge RBF0A[2], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_RBF0A);
      $setuphold (posedge CLK &&& never, negedge RBF0A[1], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_RBF0A);
      $setuphold (posedge CLK &&& never, negedge RBF0A[0], tsetup_X_CLK, thold_X_CLK, notifier_TSH_CLK_RBF0A);

      if (NMASAWL1_MASAWL0) (posedge CLK *> (Q[31] : n_Q[31])) = (tdelay_CLK_X_01, tdelay_CLK_X_10);
      if (NMASAWL1_MASAWL0) (posedge CLK *> (Q[30] : n_Q[30])) = (tdelay_CLK_X_01, tdelay_CLK_X_10);
      if (NMASAWL1_MASAWL0) (posedge CLK *> (Q[29] : n_Q[29])) = (tdelay_CLK_X_01, tdelay_CLK_X_10);
      if (NMASAWL1_MASAWL0) (posedge CLK *> (Q[28] : n_Q[28])) = (tdelay_CLK_X_01, tdelay_CLK_X_10);
      if (NMASAWL1_MASAWL0) (posedge CLK *> (Q[27] : n_Q[27])) = (tdelay_CLK_X_01, tdelay_CLK_X_10);
      if (NMASAWL1_MASAWL0) (posedge CLK *> (Q[26] : n_Q[26])) = (tdelay_CLK_X_01, tdelay_CLK_X_10);
      if (NMASAWL1_MASAWL0) (posedge CLK *> (Q[25] : n_Q[25])) = (tdelay_CLK_X_01, tdelay_CLK_X_10);
      if (NMASAWL1_MASAWL0) (posedge CLK *> (Q[24] : n_Q[24])) = (tdelay_CLK_X_01, tdelay_CLK_X_10);
      if (NMASAWL1_MASAWL0) (posedge CLK *> (Q[23] : n_Q[23])) = (tdelay_CLK_X_01, tdelay_CLK_X_10);
      if (NMASAWL1_MASAWL0) (posedge CLK *> (Q[22] : n_Q[22])) = (tdelay_CLK_X_01, tdelay_CLK_X_10);
      if (NMASAWL1_MASAWL0) (posedge CLK *> (Q[21] : n_Q[21])) = (tdelay_CLK_X_01, tdelay_CLK_X_10);
      if (NMASAWL1_MASAWL0) (posedge CLK *> (Q[20] : n_Q[20])) = (tdelay_CLK_X_01, tdelay_CLK_X_10);
      if (NMASAWL1_MASAWL0) (posedge CLK *> (Q[19] : n_Q[19])) = (tdelay_CLK_X_01, tdelay_CLK_X_10);
      if (NMASAWL1_MASAWL0) (posedge CLK *> (Q[18] : n_Q[18])) = (tdelay_CLK_X_01, tdelay_CLK_X_10);
      if (NMASAWL1_MASAWL0) (posedge CLK *> (Q[17] : n_Q[17])) = (tdelay_CLK_X_01, tdelay_CLK_X_10);
      if (NMASAWL1_MASAWL0) (posedge CLK *> (Q[16] : n_Q[16])) = (tdelay_CLK_X_01, tdelay_CLK_X_10);
      if (NMASAWL1_MASAWL0) (posedge CLK *> (Q[15] : n_Q[15])) = (tdelay_CLK_X_01, tdelay_CLK_X_10);
      if (NMASAWL1_MASAWL0) (posedge CLK *> (Q[14] : n_Q[14])) = (tdelay_CLK_X_01, tdelay_CLK_X_10);
      if (NMASAWL1_MASAWL0) (posedge CLK *> (Q[13] : n_Q[13])) = (tdelay_CLK_X_01, tdelay_CLK_X_10);
      if (NMASAWL1_MASAWL0) (posedge CLK *> (Q[12] : n_Q[12])) = (tdelay_CLK_X_01, tdelay_CLK_X_10);
      if (NMASAWL1_MASAWL0) (posedge CLK *> (Q[11] : n_Q[11])) = (tdelay_CLK_X_01, tdelay_CLK_X_10);
      if (NMASAWL1_MASAWL0) (posedge CLK *> (Q[10] : n_Q[10])) = (tdelay_CLK_X_01, tdelay_CLK_X_10);
      if (NMASAWL1_MASAWL0) (posedge CLK *> (Q[9] : n_Q[9])) = (tdelay_CLK_X_01, tdelay_CLK_X_10);
      if (NMASAWL1_MASAWL0) (posedge CLK *> (Q[8] : n_Q[8])) = (tdelay_CLK_X_01, tdelay_CLK_X_10);
      if (NMASAWL1_MASAWL0) (posedge CLK *> (Q[7] : n_Q[7])) = (tdelay_CLK_X_01, tdelay_CLK_X_10);
      if (NMASAWL1_MASAWL0) (posedge CLK *> (Q[6] : n_Q[6])) = (tdelay_CLK_X_01, tdelay_CLK_X_10);
      if (NMASAWL1_MASAWL0) (posedge CLK *> (Q[5] : n_Q[5])) = (tdelay_CLK_X_01, tdelay_CLK_X_10);
      if (NMASAWL1_MASAWL0) (posedge CLK *> (Q[4] : n_Q[4])) = (tdelay_CLK_X_01, tdelay_CLK_X_10);
      if (NMASAWL1_MASAWL0) (posedge CLK *> (Q[3] : n_Q[3])) = (tdelay_CLK_X_01, tdelay_CLK_X_10);
      if (NMASAWL1_MASAWL0) (posedge CLK *> (Q[2] : n_Q[2])) = (tdelay_CLK_X_01, tdelay_CLK_X_10);
      if (NMASAWL1_MASAWL0) (posedge CLK *> (Q[1] : n_Q[1])) = (tdelay_CLK_X_01, tdelay_CLK_X_10);
      if (NMASAWL1_MASAWL0) (posedge CLK *> (Q[0] : n_Q[0])) = (tdelay_CLK_X_01, tdelay_CLK_X_10);
      if (NMASAWL1_MASAWL0) (posedge CLK *> (QRB : n_QRB)) = (tdelay_CLK_X_01, tdelay_CLK_X_10);
      if (NMASAWL1_NMASAWL0_MASAWL1_NMASAWL0_MASAWL1_MASAWL0) (posedge CLK *> (Q[31] : n_Q[31])) = (tdelay_CLK_X_01, tdelay_CLK_X_10);
      if (NMASAWL1_NMASAWL0_MASAWL1_NMASAWL0_MASAWL1_MASAWL0) (posedge CLK *> (Q[30] : n_Q[30])) = (tdelay_CLK_X_01, tdelay_CLK_X_10);
      if (NMASAWL1_NMASAWL0_MASAWL1_NMASAWL0_MASAWL1_MASAWL0) (posedge CLK *> (Q[29] : n_Q[29])) = (tdelay_CLK_X_01, tdelay_CLK_X_10);
      if (NMASAWL1_NMASAWL0_MASAWL1_NMASAWL0_MASAWL1_MASAWL0) (posedge CLK *> (Q[28] : n_Q[28])) = (tdelay_CLK_X_01, tdelay_CLK_X_10);
      if (NMASAWL1_NMASAWL0_MASAWL1_NMASAWL0_MASAWL1_MASAWL0) (posedge CLK *> (Q[27] : n_Q[27])) = (tdelay_CLK_X_01, tdelay_CLK_X_10);
      if (NMASAWL1_NMASAWL0_MASAWL1_NMASAWL0_MASAWL1_MASAWL0) (posedge CLK *> (Q[26] : n_Q[26])) = (tdelay_CLK_X_01, tdelay_CLK_X_10);
      if (NMASAWL1_NMASAWL0_MASAWL1_NMASAWL0_MASAWL1_MASAWL0) (posedge CLK *> (Q[25] : n_Q[25])) = (tdelay_CLK_X_01, tdelay_CLK_X_10);
      if (NMASAWL1_NMASAWL0_MASAWL1_NMASAWL0_MASAWL1_MASAWL0) (posedge CLK *> (Q[24] : n_Q[24])) = (tdelay_CLK_X_01, tdelay_CLK_X_10);
      if (NMASAWL1_NMASAWL0_MASAWL1_NMASAWL0_MASAWL1_MASAWL0) (posedge CLK *> (Q[23] : n_Q[23])) = (tdelay_CLK_X_01, tdelay_CLK_X_10);
      if (NMASAWL1_NMASAWL0_MASAWL1_NMASAWL0_MASAWL1_MASAWL0) (posedge CLK *> (Q[22] : n_Q[22])) = (tdelay_CLK_X_01, tdelay_CLK_X_10);
      if (NMASAWL1_NMASAWL0_MASAWL1_NMASAWL0_MASAWL1_MASAWL0) (posedge CLK *> (Q[21] : n_Q[21])) = (tdelay_CLK_X_01, tdelay_CLK_X_10);
      if (NMASAWL1_NMASAWL0_MASAWL1_NMASAWL0_MASAWL1_MASAWL0) (posedge CLK *> (Q[20] : n_Q[20])) = (tdelay_CLK_X_01, tdelay_CLK_X_10);
      if (NMASAWL1_NMASAWL0_MASAWL1_NMASAWL0_MASAWL1_MASAWL0) (posedge CLK *> (Q[19] : n_Q[19])) = (tdelay_CLK_X_01, tdelay_CLK_X_10);
      if (NMASAWL1_NMASAWL0_MASAWL1_NMASAWL0_MASAWL1_MASAWL0) (posedge CLK *> (Q[18] : n_Q[18])) = (tdelay_CLK_X_01, tdelay_CLK_X_10);
      if (NMASAWL1_NMASAWL0_MASAWL1_NMASAWL0_MASAWL1_MASAWL0) (posedge CLK *> (Q[17] : n_Q[17])) = (tdelay_CLK_X_01, tdelay_CLK_X_10);
      if (NMASAWL1_NMASAWL0_MASAWL1_NMASAWL0_MASAWL1_MASAWL0) (posedge CLK *> (Q[16] : n_Q[16])) = (tdelay_CLK_X_01, tdelay_CLK_X_10);
      if (NMASAWL1_NMASAWL0_MASAWL1_NMASAWL0_MASAWL1_MASAWL0) (posedge CLK *> (Q[15] : n_Q[15])) = (tdelay_CLK_X_01, tdelay_CLK_X_10);
      if (NMASAWL1_NMASAWL0_MASAWL1_NMASAWL0_MASAWL1_MASAWL0) (posedge CLK *> (Q[14] : n_Q[14])) = (tdelay_CLK_X_01, tdelay_CLK_X_10);
      if (NMASAWL1_NMASAWL0_MASAWL1_NMASAWL0_MASAWL1_MASAWL0) (posedge CLK *> (Q[13] : n_Q[13])) = (tdelay_CLK_X_01, tdelay_CLK_X_10);
      if (NMASAWL1_NMASAWL0_MASAWL1_NMASAWL0_MASAWL1_MASAWL0) (posedge CLK *> (Q[12] : n_Q[12])) = (tdelay_CLK_X_01, tdelay_CLK_X_10);
      if (NMASAWL1_NMASAWL0_MASAWL1_NMASAWL0_MASAWL1_MASAWL0) (posedge CLK *> (Q[11] : n_Q[11])) = (tdelay_CLK_X_01, tdelay_CLK_X_10);
      if (NMASAWL1_NMASAWL0_MASAWL1_NMASAWL0_MASAWL1_MASAWL0) (posedge CLK *> (Q[10] : n_Q[10])) = (tdelay_CLK_X_01, tdelay_CLK_X_10);
      if (NMASAWL1_NMASAWL0_MASAWL1_NMASAWL0_MASAWL1_MASAWL0) (posedge CLK *> (Q[9] : n_Q[9])) = (tdelay_CLK_X_01, tdelay_CLK_X_10);
      if (NMASAWL1_NMASAWL0_MASAWL1_NMASAWL0_MASAWL1_MASAWL0) (posedge CLK *> (Q[8] : n_Q[8])) = (tdelay_CLK_X_01, tdelay_CLK_X_10);
      if (NMASAWL1_NMASAWL0_MASAWL1_NMASAWL0_MASAWL1_MASAWL0) (posedge CLK *> (Q[7] : n_Q[7])) = (tdelay_CLK_X_01, tdelay_CLK_X_10);
      if (NMASAWL1_NMASAWL0_MASAWL1_NMASAWL0_MASAWL1_MASAWL0) (posedge CLK *> (Q[6] : n_Q[6])) = (tdelay_CLK_X_01, tdelay_CLK_X_10);
      if (NMASAWL1_NMASAWL0_MASAWL1_NMASAWL0_MASAWL1_MASAWL0) (posedge CLK *> (Q[5] : n_Q[5])) = (tdelay_CLK_X_01, tdelay_CLK_X_10);
      if (NMASAWL1_NMASAWL0_MASAWL1_NMASAWL0_MASAWL1_MASAWL0) (posedge CLK *> (Q[4] : n_Q[4])) = (tdelay_CLK_X_01, tdelay_CLK_X_10);
      if (NMASAWL1_NMASAWL0_MASAWL1_NMASAWL0_MASAWL1_MASAWL0) (posedge CLK *> (Q[3] : n_Q[3])) = (tdelay_CLK_X_01, tdelay_CLK_X_10);
      if (NMASAWL1_NMASAWL0_MASAWL1_NMASAWL0_MASAWL1_MASAWL0) (posedge CLK *> (Q[2] : n_Q[2])) = (tdelay_CLK_X_01, tdelay_CLK_X_10);
      if (NMASAWL1_NMASAWL0_MASAWL1_NMASAWL0_MASAWL1_MASAWL0) (posedge CLK *> (Q[1] : n_Q[1])) = (tdelay_CLK_X_01, tdelay_CLK_X_10);
      if (NMASAWL1_NMASAWL0_MASAWL1_NMASAWL0_MASAWL1_MASAWL0) (posedge CLK *> (Q[0] : n_Q[0])) = (tdelay_CLK_X_01, tdelay_CLK_X_10);
      if (NMASAWL1_NMASAWL0_MASAWL1_NMASAWL0_MASAWL1_MASAWL0) (posedge CLK *> (QRB : n_QRB)) = (tdelay_CLK_X_01, tdelay_CLK_X_10);

      (posedge AS => (OBSV_CTL : AS)) = (tdelay_PROP_X_01, tdelay_PROP_X_10);
      (posedge AW[4] => (OBSV_CTL : AW[4])) = (tdelay_PROP_X_01, tdelay_PROP_X_10);
      (posedge AW[3] => (OBSV_CTL : AW[3])) = (tdelay_PROP_X_01, tdelay_PROP_X_10);
      (posedge AW[2] => (OBSV_CTL : AW[2])) = (tdelay_PROP_X_01, tdelay_PROP_X_10);
      (posedge AW[1] => (OBSV_CTL : AW[1])) = (tdelay_PROP_X_01, tdelay_PROP_X_10);
      (posedge AW[0] => (OBSV_CTL : AW[0])) = (tdelay_PROP_X_01, tdelay_PROP_X_10);
      (posedge AC[2] => (OBSV_CTL : AC[2])) = (tdelay_PROP_X_01, tdelay_PROP_X_10);
      (posedge AC[1] => (OBSV_CTL : AC[1])) = (tdelay_PROP_X_01, tdelay_PROP_X_10);
      (posedge AC[0] => (OBSV_CTL : AC[0])) = (tdelay_PROP_X_01, tdelay_PROP_X_10);
      (posedge CEN            => (OBSV_CTL : CEN))            = (tdelay_PROP_X_01, tdelay_PROP_X_10);
      (posedge RDWEN          => (OBSV_CTL : RDWEN))          = (tdelay_PROP_X_01, tdelay_PROP_X_10);
      (posedge DEEPSLEEP      => (OBSV_CTL : DEEPSLEEP))      = (tdelay_PROP_X_01, tdelay_PROP_X_10);
      (posedge POWERGATE      => (OBSV_CTL : POWERGATE))      = (tdelay_PROP_X_01, tdelay_PROP_X_10);
      (negedge AS => (OBSV_CTL : AS)) = (tdelay_PROP_X_01, tdelay_PROP_X_10);
      (negedge AW[4] => (OBSV_CTL : AW[4])) = (tdelay_PROP_X_01, tdelay_PROP_X_10);
      (negedge AW[3] => (OBSV_CTL : AW[3])) = (tdelay_PROP_X_01, tdelay_PROP_X_10);
      (negedge AW[2] => (OBSV_CTL : AW[2])) = (tdelay_PROP_X_01, tdelay_PROP_X_10);
      (negedge AW[1] => (OBSV_CTL : AW[1])) = (tdelay_PROP_X_01, tdelay_PROP_X_10);
      (negedge AW[0] => (OBSV_CTL : AW[0])) = (tdelay_PROP_X_01, tdelay_PROP_X_10);
      (negedge AC[2] => (OBSV_CTL : AC[2])) = (tdelay_PROP_X_01, tdelay_PROP_X_10);
      (negedge AC[1] => (OBSV_CTL : AC[1])) = (tdelay_PROP_X_01, tdelay_PROP_X_10);
      (negedge AC[0] => (OBSV_CTL : AC[0])) = (tdelay_PROP_X_01, tdelay_PROP_X_10);
      (negedge CEN            => (OBSV_CTL : CEN))            = (tdelay_PROP_X_01, tdelay_PROP_X_10);
      (negedge RDWEN          => (OBSV_CTL : RDWEN))          = (tdelay_PROP_X_01, tdelay_PROP_X_10);
      (negedge DEEPSLEEP      => (OBSV_CTL : DEEPSLEEP))      = (tdelay_PROP_X_01, tdelay_PROP_X_10);
      (negedge POWERGATE      => (OBSV_CTL : POWERGATE))      = (tdelay_PROP_X_01, tdelay_PROP_X_10);
      (posedge T_AS => (OBSV_CTL : T_AS)) = (tdelay_PROP_X_01, tdelay_PROP_X_10);
      (posedge T_AW[4] => (OBSV_CTL : T_AW[4])) = (tdelay_PROP_X_01, tdelay_PROP_X_10);
      (posedge T_AW[3] => (OBSV_CTL : T_AW[3])) = (tdelay_PROP_X_01, tdelay_PROP_X_10);
      (posedge T_AW[2] => (OBSV_CTL : T_AW[2])) = (tdelay_PROP_X_01, tdelay_PROP_X_10);
      (posedge T_AW[1] => (OBSV_CTL : T_AW[1])) = (tdelay_PROP_X_01, tdelay_PROP_X_10);
      (posedge T_AW[0] => (OBSV_CTL : T_AW[0])) = (tdelay_PROP_X_01, tdelay_PROP_X_10);
      (posedge T_AC[2] => (OBSV_CTL : T_AC[2])) = (tdelay_PROP_X_01, tdelay_PROP_X_10);
      (posedge T_AC[1] => (OBSV_CTL : T_AC[1])) = (tdelay_PROP_X_01, tdelay_PROP_X_10);
      (posedge T_AC[0] => (OBSV_CTL : T_AC[0])) = (tdelay_PROP_X_01, tdelay_PROP_X_10);
      (posedge T_CEN            => (OBSV_CTL : T_CEN))            = (tdelay_PROP_X_01, tdelay_PROP_X_10);
      (posedge T_RDWEN          => (OBSV_CTL : T_RDWEN))          = (tdelay_PROP_X_01, tdelay_PROP_X_10);
      (posedge T_DEEPSLEEP      => (OBSV_CTL : T_DEEPSLEEP))      = (tdelay_PROP_X_01, tdelay_PROP_X_10);
      (posedge T_POWERGATE      => (OBSV_CTL : T_POWERGATE))      = (tdelay_PROP_X_01, tdelay_PROP_X_10);
      (negedge T_AS => (OBSV_CTL : T_AS)) = (tdelay_PROP_X_01, tdelay_PROP_X_10);
      (negedge T_AW[4] => (OBSV_CTL : T_AW[4])) = (tdelay_PROP_X_01, tdelay_PROP_X_10);
      (negedge T_AW[3] => (OBSV_CTL : T_AW[3])) = (tdelay_PROP_X_01, tdelay_PROP_X_10);
      (negedge T_AW[2] => (OBSV_CTL : T_AW[2])) = (tdelay_PROP_X_01, tdelay_PROP_X_10);
      (negedge T_AW[1] => (OBSV_CTL : T_AW[1])) = (tdelay_PROP_X_01, tdelay_PROP_X_10);
      (negedge T_AW[0] => (OBSV_CTL : T_AW[0])) = (tdelay_PROP_X_01, tdelay_PROP_X_10);
      (negedge T_AC[2] => (OBSV_CTL : T_AC[2])) = (tdelay_PROP_X_01, tdelay_PROP_X_10);
      (negedge T_AC[1] => (OBSV_CTL : T_AC[1])) = (tdelay_PROP_X_01, tdelay_PROP_X_10);
      (negedge T_AC[0] => (OBSV_CTL : T_AC[0])) = (tdelay_PROP_X_01, tdelay_PROP_X_10);
      (negedge T_CEN            => (OBSV_CTL : T_CEN))            = (tdelay_PROP_X_01, tdelay_PROP_X_10);
      (negedge T_RDWEN          => (OBSV_CTL : T_RDWEN))          = (tdelay_PROP_X_01, tdelay_PROP_X_10);
      (negedge T_DEEPSLEEP      => (OBSV_CTL : T_DEEPSLEEP))      = (tdelay_PROP_X_01, tdelay_PROP_X_10);
      (negedge T_POWERGATE      => (OBSV_CTL : T_POWERGATE))      = (tdelay_PROP_X_01, tdelay_PROP_X_10);
      (posedge T_BIST           => (OBSV_CTL : T_BIST))            = (tdelay_PROP_X_01, tdelay_PROP_X_10);
      (negedge T_BIST           => (OBSV_CTL : T_BIST))            = (tdelay_PROP_X_01, tdelay_PROP_X_10);

   endspecify

endmodule
`endcelldefine
module IN22FDX_S1P_BFRG_W00320B032M08C128_memory_generic
  #(
`ifdef IVCS_MSG_LVL
    parameter MSG_LVL         = `IVCS_MSG_LVL,
`else
    parameter MSG_LVL         = 2,
`endif
    parameter SKIP_POR        = 0,
    parameter TESTCHIP        = 0,
    parameter ALLOW_MA        = 0, // =1 will allow ma_sawl to be at a non-zero value

    parameter PreloadArrayBinFile = "NONE",
    parameter PreloadArrayHexFile = "NONE",

`ifndef IVCS_FAST_FUNC
    // The following parameters are locally defined to force W/L, B/L and
    // single cell fails. If they are not overridden with a heirarchical
    // defparam at a higher level, no fails will be injected
    parameter WL_FAIL         = 0, // =1 if a w/l fail is being forced
    parameter WL_FAIL_RWL     = 0, // =1 if this is a redundant w/l fail
    parameter WL_FAIL_SUB     = 0, // subarray address of w/l fail
    parameter WL_FAIL_ROW     = 0, // row address of w/l fail -- only 0-1 are valid if WL_FAIL_RWL=1
    parameter WL_FAIL_DATA    = 0, // data to force onto every bit of the failing WL

    parameter BL_FAIL         = 0, // =1 if a b/l fail is being forced
    parameter BL_FAIL_RBL     = 0, // =1 if this is a red. b/l fail
    parameter BL_FAIL_COL     = 0, // column address of b/l fail -- only 0-3 are valid if BL_FAIL_RBL=1
    parameter BL_FAIL_BIT     = 0, // failing b/l -- only 0-1 are valid if BL_FAIL_RBL=1
    parameter BL_FAIL_DATA    = 0, // data to force onto every bit of the failing BL

    parameter CELL0_FAIL      = 0, // =1 if 1st single cell fail is being forced
    parameter CELL0_FAIL_RBL  = 0, // =1 if this is a red. b/l fail
    parameter CELL0_FAIL_RWL  = 0, // =1 if this is a red. w/l fail
    parameter CELL0_FAIL_SUB  = 0, // subarray address of single cell fail 0
    parameter CELL0_FAIL_ROW  = 0, // row address of single cell fail 0    -- only 0-1 are valid if CELL0_FAIL_RWL=1
    parameter CELL0_FAIL_COL  = 0, // column address of single cell fail 0 -- only 0-3 are valid if CELL0_FAIL_RBL=1
    parameter CELL0_FAIL_BIT  = 0, // b/l of single cell fail 0            -- only 0-1 are valid if CELL0_FAIL_RBL=1
    parameter CELL0_FORCE_DATA= 0, // data to force on the read of failing cell 0

    parameter CELL1_FAIL      = 0, // =1 if 2nd single cell fail is being forced
    parameter CELL1_FAIL_RBL  = 0, // =1 if this is a red. b/l fail
    parameter CELL1_FAIL_RWL  = 0, // =1 if this is a red. w/l fail
    parameter CELL1_FAIL_SUB  = 0, // subarray address of single cell fail 1
    parameter CELL1_FAIL_ROW  = 0, // row address of single cell fail 1    -- only 0-1 are valid if CELL1_FAIL_RWL=1
    parameter CELL1_FAIL_COL  = 0, // column address of single cell fail 1 -- only 0-3 are valid if CELL1_FAIL_RBL=1
    parameter CELL1_FAIL_BIT  = 0, // b/l of single cell fail 1            -- only 0-1 are valid if CELL1_FAIL_RBL=1
    parameter CELL1_FORCE_DATA= 0, // data to force on the read of failing cell 1

    parameter CELL2_FAIL      = 0, // =1 if 3rd single cell fail is being forced
    parameter CELL2_FAIL_RBL  = 0, // =1 if this is a red. b/l fail
    parameter CELL2_FAIL_RWL  = 0, // =1 if this is a red. w/l fail
    parameter CELL2_FAIL_SUB  = 0, // subarray address of single cell fail 2
    parameter CELL2_FAIL_ROW  = 0, // row address of single cell fail 2    -- only 0-1 are valid if CELL2_FAIL_RWL=1
    parameter CELL2_FAIL_COL  = 0, // column address of single cell fail 2 -- only 0-3 are valid if CELL2_FAIL_RBL=1
    parameter CELL2_FAIL_BIT  = 0, // b/l of single cell fail 2            -- only 0-1 are valid if CELL2_FAIL_RBL=1
    parameter CELL2_FORCE_DATA= 0, // data to force on the read of failing cell 2

    parameter CELL3_FAIL      = 0, // =1 if 4th single cell fail is being forced
    parameter CELL3_FAIL_RBL  = 0, // =1 if this is a red. b/l fail
    parameter CELL3_FAIL_RWL  = 0, // =1 if this is a red. w/l fail
    parameter CELL3_FAIL_SUB  = 0, // subarray address of single cell fail 3
    parameter CELL3_FAIL_ROW  = 0, // row address of single cell fail 3    -- only 0-1 are valid if CELL3_FAIL_RWL=1
    parameter CELL3_FAIL_COL  = 0, // column address of single cell fail 3 -- only 0-3 are valid if CELL3_FAIL_RBL=1
    parameter CELL3_FAIL_BIT  = 0, // b/l of single cell fail 3            -- only 0-1 are valid if CELL3_FAIL_RBL=1
    parameter CELL3_FORCE_DATA= 0, // data to force on the read of failing cell 3
`endif

    // These parameters define the size and decode of the SRAM
    parameter W_DEPTH=8192,         // total array depth (banks x rows x cols)
    parameter NUM_SEG=2,            // one or 2 segments?
    parameter AS_SIZE=3,            // bits required for bank address
    parameter AW_SIZE=8,            // bits required for row address
    parameter AC_SIZE=2,            // bits required for column address
    parameter D_SIZE=160,           // bit width of the SRAM
    parameter CYCLE_TIME =   1.000,
    parameter SETUP_TIME =   0.010,
    parameter PG_TO_CEN  =  40.000,
    parameter DS_TO_CEN  = 200.000

    )
   (
    inout VDD,
    inout VCS,
    inout VBN,
    inout VBP,
    inout VSS,

    input pipeline,

    input notifier,
    input clk,

    input deepsleep,
    input powergate,

    input cen,
    input rdwen,
    input [AS_SIZE-1:0] as,
    input [AW_SIZE-1:0] aw,
    input [AC_SIZE-1:0] ac,
    input [D_SIZE-1:0] d,
    input [D_SIZE-1:0] bw,

    input t_deepsleep,
    input t_powergate,

    input t_cen,
    input t_rdwen,
    input [AS_SIZE-1:0] t_as,
    input [AW_SIZE-1:0] t_aw,
    input [AC_SIZE-1:0] t_ac,
    input [D_SIZE-1:0] t_d,
    input [D_SIZE-1:0] t_bw,

    input t_bist,
    input t_logic,
    input t_wbt,
    input t_stab,
    input [1:0] ma_sawl,
    input [1:0] ma_wl,
    input [1:0] ma_wras,
    input ma_wrasd,
    input [1:0] rbe,
    input [6:0] rbf1a,
    input [6:0] rbf0a,
    input [1:0] rwe,
    input [7:0] rwf1a,
    input [7:0] rwf0a,

    output [D_SIZE-1:0] q,
    output [1:0] qrb,
    output obsv_ctl

    );

   // Internal versions of the inputs after muxing/gating
   wire cenI;
   wire rdwenI;
   wire [AS_SIZE-1:0] asI;
   wire [AW_SIZE-1:0] awI;
   wire [AC_SIZE-1:0] acI;
   wire [D_SIZE-1:0]  dI;
   wire [D_SIZE-1:0]  bwI;
   wire deepsleepI;
   wire powergateI;

   assign obsv_ctl = ~t_logic | ((&(~asI)) & (&(~awI)) & (&acI) & rdwenI & ~cenI & ~deepsleepI & ~powergateI);

`ifdef IVCS_CYCLE_SIM

   localparam A_SIZE = AS_SIZE + AW_SIZE + AC_SIZE;
   localparam ARRAY_DEPTH = W_DEPTH;

   reg [D_SIZE-1:0] array [0:ARRAY_DEPTH-1];
   reg [D_SIZE-1:0] data_l1;
   reg [D_SIZE-1:0] data_l2;

   // BIST muxing
   assign cenI       = t_bist ? t_cen       : cen;
   assign rdwenI     = t_bist ? t_rdwen     : rdwen;
   assign asI        = t_bist ? t_as        : as;
   assign awI        = t_bist ? t_aw        : aw;
   assign acI        = t_bist ? t_ac        : ac;
   assign dI         = t_bist ? t_d         : d;
   assign bwI        = t_bist ? t_bw        : bw;
   assign deepsleepI = t_bist ? t_deepsleep : deepsleep;
   assign powergateI = t_bist ? t_powergate : powergate;

   wire [A_SIZE-1:0] aI = {awI[AW_SIZE-1:2], asI, awI[1:0], acI};

   always @(posedge clk) begin

      // Test function
      if (t_logic) begin
         data_l1 <= (dI & bwI) | (~dI & ~bwI);
      end

      // Read
      if (!t_logic && !deepsleepI && !powergateI && !cenI && rdwenI) begin
         data_l1 <= array[aI];
      end
      data_l2 <= data_l1;

      // Write
      if (!t_logic && !deepsleepI && !powergateI && !cenI && !rdwenI) begin
         array[aI] <= (bwI & dI) | (~bwI & array[aI]);
      end

   end

   // Generate Q output
   assign q = pipeline ? data_l2 : data_l1;

   // Tie unused outputs
   assign qrb = 0;

`else // !`ifdef  IVCS_CYCLE_SIM

   ////////////////////////////////////////////////////
   // Local parameter / wire / reg definition
   ////////////////////////////////////////////////////

   //Assign user controlled parameters to wires so they can be forced as needed
   wire        TESTCHIP_wire    = TESTCHIP;
   wire        SKIP_POR_wire    = SKIP_POR;

   // Segment math
   localparam MUX       = (2**AC_SIZE);

 `ifndef IVCS_FAST_FUNC
   // This is a trick to account for how M04 memories always grow bits in pairs
   localparam D_SIZEX = (MUX==4) ? (D_SIZE/2) : D_SIZE;
   localparam M04_MULT = (MUX==4) ? 2 : 1;

   // 1-segment calculations
   localparam Q0_SIZE_1SEG = D_SIZEX/2;
   localparam Q1_SIZE_1SEG = D_SIZEX - Q0_SIZE_1SEG;

   // 2-segment calculations

   // If D_SIZE MODULO 4 = 0, then all quads equal D_SIZE/4
   // If D_SIZE MODULO 4 = 1, then q1 is floor(D_SIZE/4) + 1
   // If D_SIZE MODULE 4 = 2, then q1 and q3 are floor(D_SIZE/4) + 1
   // If D_SIZE MODULE 4 = 3, then q0, q1, and q3 are floor(D_SIZE/4) + 1

   localparam Q0_SIZE_2SEG = (D_SIZEX/4) + ((D_SIZEX%4) > 2 ? 1 : 0);
   localparam Q1_SIZE_2SEG = (D_SIZEX/4) + ((D_SIZEX%4) > 0 ? 1 : 0);
   localparam Q2_SIZE_2SEG = (D_SIZEX/4);
   localparam Q3_SIZE_2SEG = D_SIZEX - Q0_SIZE_2SEG - Q1_SIZE_2SEG - Q2_SIZE_2SEG;

   // Now put it all together
   localparam Q0_SIZE = M04_MULT * ((NUM_SEG>1) ? Q0_SIZE_2SEG : Q0_SIZE_1SEG);
   localparam Q1_SIZE = M04_MULT * ((NUM_SEG>1) ? Q1_SIZE_2SEG : Q1_SIZE_1SEG);
   localparam Q2_SIZE = M04_MULT * ((NUM_SEG>1) ? Q2_SIZE_2SEG : Q0_SIZE_1SEG);
   localparam Q3_SIZE = M04_MULT * ((NUM_SEG>1) ? Q3_SIZE_2SEG : Q1_SIZE_1SEG);

   localparam Q0_LSB = 0;
   localparam Q1_LSB = Q0_SIZE;
   localparam Q2_LSB = (NUM_SEG>1) ? Q0_SIZE + Q1_SIZE           : 0;
   localparam Q3_LSB = (NUM_SEG>1) ? Q0_SIZE + Q1_SIZE + Q2_SIZE : Q0_SIZE;

   localparam SEG0_SIZE = Q0_SIZE + Q1_SIZE;
   localparam SEG1_SIZE = Q2_SIZE + Q3_SIZE;

   localparam SEG0_MSB  = SEG0_SIZE-1;
   localparam SEG1_LSB  = (NUM_SEG>1) ? SEG0_SIZE : 0;
   localparam SEG1_MSB  = D_SIZE-1;

   wire        WL_FAIL_wire          = WL_FAIL;
   wire        WL_FAIL_RWL_wire      = WL_FAIL_RWL;
   wire [31:0] WL_FAIL_SUB_wire      = WL_FAIL_SUB;
   wire [31:0] WL_FAIL_ROW_wire      = WL_FAIL_ROW;
   wire        WL_FAIL_DATA_wire     = WL_FAIL_DATA;

   wire        BL_FAIL_wire          = BL_FAIL;
   wire        BL_FAIL_RBL_wire      = BL_FAIL_RBL;
   wire [31:0] BL_FAIL_COL_wire      = BL_FAIL_COL;
   wire [31:0] BL_FAIL_BIT_wire      = BL_FAIL_BIT;
   wire        BL_FAIL_DATA_wire     = BL_FAIL_DATA;

   wire        CELL0_FAIL_wire       = CELL0_FAIL;
   wire        CELL0_FAIL_RBL_wire   = CELL0_FAIL_RBL;
   wire        CELL0_FAIL_RWL_wire   = CELL0_FAIL_RWL;
   wire [31:0] CELL0_FAIL_SUB_wire   = CELL0_FAIL_SUB;
   wire [31:0] CELL0_FAIL_ROW_wire   = CELL0_FAIL_ROW;
   wire [31:0] CELL0_FAIL_COL_wire   = CELL0_FAIL_COL;
   wire [31:0] CELL0_FAIL_BIT_wire   = CELL0_FAIL_BIT;
   wire        CELL0_FORCE_DATA_wire = CELL0_FORCE_DATA;

   wire        CELL1_FAIL_wire       = CELL1_FAIL;
   wire        CELL1_FAIL_RBL_wire   = CELL1_FAIL_RBL;
   wire        CELL1_FAIL_RWL_wire   = CELL1_FAIL_RWL;
   wire [31:0] CELL1_FAIL_SUB_wire   = CELL1_FAIL_SUB;
   wire [31:0] CELL1_FAIL_ROW_wire   = CELL1_FAIL_ROW;
   wire [31:0] CELL1_FAIL_COL_wire   = CELL1_FAIL_COL;
   wire [31:0] CELL1_FAIL_BIT_wire   = CELL1_FAIL_BIT;
   wire        CELL1_FORCE_DATA_wire = CELL1_FORCE_DATA;

   wire        CELL2_FAIL_wire       = CELL2_FAIL;
   wire        CELL2_FAIL_RBL_wire   = CELL2_FAIL_RBL;
   wire        CELL2_FAIL_RWL_wire   = CELL2_FAIL_RWL;
   wire [31:0] CELL2_FAIL_SUB_wire   = CELL2_FAIL_SUB;
   wire [31:0] CELL2_FAIL_ROW_wire   = CELL2_FAIL_ROW;
   wire [31:0] CELL2_FAIL_COL_wire   = CELL2_FAIL_COL;
   wire [31:0] CELL2_FAIL_BIT_wire   = CELL2_FAIL_BIT;
   wire        CELL2_FORCE_DATA_wire = CELL2_FORCE_DATA;

   wire        CELL3_FAIL_wire       = CELL3_FAIL;
   wire        CELL3_FAIL_RBL_wire   = CELL3_FAIL_RBL;
   wire        CELL3_FAIL_RWL_wire   = CELL3_FAIL_RWL;
   wire [31:0] CELL3_FAIL_SUB_wire   = CELL3_FAIL_SUB;
   wire [31:0] CELL3_FAIL_ROW_wire   = CELL3_FAIL_ROW;
   wire [31:0] CELL3_FAIL_COL_wire   = CELL3_FAIL_COL;
   wire [31:0] CELL3_FAIL_BIT_wire   = CELL3_FAIL_BIT;
   wire        CELL3_FORCE_DATA_wire = CELL3_FORCE_DATA;

   wire any_fail = CELL0_FAIL_wire | CELL1_FAIL_wire | CELL2_FAIL_wire | CELL3_FAIL_wire | WL_FAIL_wire | BL_FAIL_wire;
 `endif

   // Internal versions of the inputs after muxing/gating
   wire [1:0] rbeI;
   wire [6:0] rbfI [1:0];
   wire [1:0] rweI;
   wire [7:0] rwfI [1:0];
   wire [1:0] ma_sawlI;
   wire [1:0] ma_wlI;
   wire [1:0] ma_wrasI;
   wire       ma_wrasdI;


   //////////////////////////////////////////////////////////////////////
   // Declare the memory array
   //////////////////////////////////////////////////////////////////////

   localparam NUMSUB = (2**AS_SIZE);
   localparam A_SIZE = AS_SIZE + AW_SIZE + AC_SIZE;

   // Oversize depth of array to account for 2 pairs of RWL per subarray
   localparam ARRAY_DEPTH = W_DEPTH + 4*NUMSUB*MUX;

   reg [D_SIZE-1:0] array [0:ARRAY_DEPTH-1];

 `ifndef IVCS_FAST_FUNC
   // RBL is always MUX4
   localparam RBL_DEPTH = W_DEPTH + 4*NUMSUB*4;

   reg [1:0] arrayRBL [0:RBL_DEPTH-1];
 `endif

   // Internal clocks
   reg  clkGate;
   wire clkI;
   reg  iClk;
   reg  oldClk;

   // Flags to indicate known good input states
   wire readOK;
   wire inputXOR;

   // Various registers used by array reads/writes
   reg [D_SIZE-1:0] array_data;
   reg [D_SIZE-1:0] data_l1;
   reg [D_SIZE-1:0] data_l2;
   reg [1:0] array_red_data;
   reg [1:0] red_data_l1;
   reg [1:0] red_data_l2;

   ////////////////////////////////////////////////////
   // BIST mux / scan mux
   ////////////////////////////////////////////////////

   // BIST mux with SETUP_TIME delay added to require setup time > 0
   assign #SETUP_TIME cenI       = t_bist ? t_cen       : cen;
   assign #SETUP_TIME rdwenI     = t_bist ? t_rdwen     : rdwen;
   assign #SETUP_TIME asI        = t_bist ? t_as        : as;
   assign #SETUP_TIME awI        = t_bist ? t_aw        : aw;
   assign #SETUP_TIME acI        = t_bist ? t_ac        : ac;
   assign #SETUP_TIME dI         = t_bist ? t_d         : d;
   assign #SETUP_TIME bwI        = t_bist ? t_bw        : bw;
   assign #SETUP_TIME deepsleepI = t_bist ? t_deepsleep : deepsleep;
   assign #SETUP_TIME powergateI = t_bist ? t_powergate : powergate;

   // Assign red. w/l and b/l to their internal array equivalent for ease of use
   assign rbeI          = SKIP_POR_wire               ? 0 : rbe;
   assign rbfI[0]       = (SKIP_POR_wire || !rbeI[0]) ? 0 : rbf0a;
   assign rbfI[1]       = (SKIP_POR_wire || !rbeI[1]) ? 0 : rbf1a;
   assign rweI          = SKIP_POR_wire               ? 0 : rwe;
   assign rwfI[0]       = (SKIP_POR_wire || !rweI[0]) ? 0 : rwf0a;
   assign rwfI[1]       = (SKIP_POR_wire || !rweI[1]) ? 0 : rwf1a;
   assign ma_sawlI      = SKIP_POR_wire               ? 0 : ma_sawl;
   assign ma_wlI        = SKIP_POR_wire               ? 0 : ma_wl;
   assign ma_wrasI      = SKIP_POR_wire               ? 0 : ma_wras;
   assign ma_wrasdI     = SKIP_POR_wire               ? 0 : ma_wrasd;

   ////////////////////////////////////////////////////
   // Check inputs, power supplies, timing notifier, etc.
   ////////////////////////////////////////////////////

   wire pModeFatal;

   // Messaging triggers
   reg [13:0] msgTrigger;

   localparam MSG_DS    =  0;
   localparam MSG_IOK   =  1;
   localparam MSG_INIT  =  2;
   localparam MSG_MA    =  3;
   localparam MSG_OOB   =  4;
   localparam MSG_PMODE =  5;
   localparam MSG_POR   =  6;
   localparam MSG_RD    =  7;
   localparam MSG_RX    =  8;
   localparam MSG_STAB  =  9;
   localparam MSG_VOLT  = 10;
   localparam MSG_WBT   = 11;
   localparam MSG_KA    = 12;
   localparam MSG_CLK   = 13;

   // non-killArray triggers
   reg startTrigger;
   reg porTrigger;
   reg dsTrigger;

   // killArray triggers
   reg [8:0] killArray;
   wire killArrayOR;
   reg  killFlag;

   localparam KA_IXOR  = 0;
   localparam KA_VOLT  = 1;
   localparam KA_PMODE = 2;
   localparam KA_CLK   = 3;
   localparam KA_MA    = 4;
   localparam KA_RX    = 5;
   localparam KA_TMG   = 6;
   localparam KA_STAB  = 7;
   localparam KA_WBT   = 8;

   // killData triggers
   reg [2:0] killData;
   wire killDataOR;
   reg killDataFlag;

   localparam KD_RX   = 0;
   localparam KD_STAB = 1;
   localparam KD_VOLT = 2;

   integer cnt;

   // T_STAB and MA must be at correct value during read operations
   assign readOK = (t_stab===1'b0) &
                   (TESTCHIP_wire | ((ALLOW_MA | ((ma_sawlI===0) & (ma_wlI===0))) & (ma_wrasdI===0) & (ma_wrasI===0)));

   //No x's on inputs (check after SKIP_POR gating such that X's are ignored if SKIP_POR is asserted)
   assign inputXOR = ((ma_sawlI   ^ ma_sawlI  ) === 0 &
                      (ma_wlI     ^ ma_wlI    ) === 0 &
                      (ma_wrasI   ^ ma_wrasI  ) === 0 &
                      (ma_wrasdI  ^ ma_wrasdI ) === 0 &
                      (rbeI       ^ rbeI      ) === 0 &
                      (rbfI[0]    ^ rbfI[0]   ) === 0 &
                      (rbfI[1]    ^ rbfI[1]   ) === 0 &
                      (rweI       ^ rweI      ) === 0 &
                      (rwfI[0]    ^ rwfI[0]   ) === 0 &
                      (rwfI[1]    ^ rwfI[1]   ) === 0 &
                      (pipeline   ^ pipeline  ) === 0 &
                      (t_bist     ^ t_bist    ) === 0 &
                      (t_logic    ^ t_logic   ) === 0 &
                      (t_stab     ^ t_stab    ) === 0 &
                      (t_wbt      ^ t_wbt     ) === 0 &
                      (~t_bist & (deepsleep   ^ deepsleep  )) === 0 &
                      (~t_bist & (powergate   ^ powergate  )) === 0 &
                      ( t_bist & (t_deepsleep ^ t_deepsleep)) === 0 &
                      ( t_bist & (t_powergate ^ t_powergate)) === 0);

   // Async error/warning checks
   always @(SKIP_POR_wire or inputXOR or t_logic or pModeFatal or deepsleepI or t_stab or t_wbt or t_bist or cen or t_cen or clk) begin

      if (startTrigger) begin

         // Warn the user
         if (SKIP_POR_wire && !porTrigger) begin
            WARNING_TASK(MSG_POR, "SKIP_POR is set. Skipping proper memory initialization requirements.");
            msgTrigger[MSG_POR]=0;
            WARNING_TASK(MSG_POR, "Please remember to simulate a true memory init sequence prior to completing a chip design.");
            porTrigger = 1;
         end

         // Check for X on any inputs monitored by inputXOR above
         if ((t_logic!==1'b1) && !inputXOR && !killArray[KA_IXOR]) begin
            ERROR_TASK(MSG_IOK, "One or more async/DC inputs (T_BIST, T_LOGIC, etc.) are unknown. Array contents are now invalid.");
            killArray[KA_IXOR] = 1;
         end

         // Triggered by powermode state machine
         if (pModeFatal && !killArray[KA_PMODE]) begin
            ERROR_TASK(MSG_PMODE, "Incorrect DEEPSLEEP/POWERGATE usage. Array contents are now invalid.");
            killArray[KA_PMODE] = 1;
         end

         // Check if DEEPSLEEP/T_DEEPSLEEP comes on at any point
         if (!t_logic && deepsleepI && !dsTrigger) begin
            INFO_TASK(MSG_DS, "DEEPSLEEP or T_DEEPSLEEP is active. Array contents are now invalid.");
            dsTrigger = 1;
         end

         // Check if STAB comes on when CEN is active low
         if (!t_logic && t_stab && ((!t_bist && !cen) || (t_bist && !t_cen)) && !killArray[KA_STAB]) begin
            if (!TESTCHIP_wire && !t_bist) begin
               ERROR_TASK(MSG_STAB, "T_STAB is NOT at 0 when CEN is active. This is not allowed for functional operations. Array contents are now invalid.");
               killArray[KA_STAB] = 1;
            end
            else begin
               WARNING_TASK(MSG_STAB, "T_STAB is NOT at 0 when CEN or T_CEN is active. This can cause incorrect memory operation during test modes and should be reviewed.");
               killData[KD_STAB] = 1;
            end
         end

         // Check if WBT comes on when CEN is active low
         if (!t_logic && t_wbt && ((!t_bist && !cen) || (t_bist && !t_cen)) && !killArray[KA_WBT]) begin
            if (!TESTCHIP_wire && !t_bist) begin
               ERROR_TASK(MSG_WBT, "T_WBT is NOT at 0 when CEN is active. This is not allowed for functional operations. Array contents are now invalid.");
               killArray[KA_WBT] = 1;
            end
            else begin
               WARNING_TASK(MSG_WBT, "T_WBT is NOT at 0 when CEN or T_CEN is active. This can cause incorrect memory operation during test modes and should be reviewed.");
            end
         end

         // These triggers clear as soon as the onset condition goes away
         if (!SKIP_POR_wire                                  ) porTrigger          = 0;
         if (inputXOR                                        ) killArray[KA_IXOR]  = 0;
         if (!pModeFatal                                     ) killArray[KA_PMODE] = 0;
         if (!deepsleepI                                     ) dsTrigger           = 0;
         if (!t_stab || (!t_bist && cen) || (t_bist && t_cen)) { killArray[KA_STAB], killData[KD_STAB] } = 2'b00;
         if (!t_wbt  || (!t_bist && cen) || (t_bist && t_cen)) killArray[KA_WBT]   = 0;

      end // if (startTrigger)
   end

   // Similar to above, but any transition (rather than a particular state) will wipe out the array
   // These triggers are cleared in the array access block after killing the array
   always @(ma_sawl or ma_wl or ma_wras or ma_wrasd) begin
      if (startTrigger && !t_logic && !killArray[KA_MA] && !cenI) begin
         if (!TESTCHIP_wire) begin
            ERROR_TASK(MSG_MA, "Margin Adjust (MA_*) signals are switching when CEN or T_CEN is active. This could cause incorrect memory operation. Array contents are now invalid.");
            killArray[KA_MA] = 1;
         end
         else begin
            WARNING_TASK(MSG_MA, "Margin Adjust (MA_*) signals are switching when CEN or T_CEN is active. This could cause incorrect memory operation and should be reviewed.");
         end
      end
   end

   always @(rbeI or rbfI[0] or rbfI[1]  or rweI or rwfI[0] or rwfI[1]) begin
      if (startTrigger && !t_logic) begin
         if (!killArray[KA_RX] && !cenI && !rdwenI) begin
            ERROR_TASK(MSG_RX, "Redundancy steering inputs (RB* or RW*) are switching when a write is active. This could cause incorrect memory operation. Array contents are now invalid.");
            killArray[KA_RX] = 1;
         end
         if (!killData[KD_RX] && !cenI && rdwenI) begin
            ERROR_TASK(MSG_RX, "Redundancy steering inputs (RB* or RW*) are switching when a read is active. Output Q are now invalid.");
            killData[KD_RX] = 1;
         end
      end
   end

 `ifdef IVCS_PG
   //Power supplies (if present in the model)
   always @ (VDD or VSS or VCS or VBN or VBP or startTrigger or clk) begin
      if(startTrigger) begin

         if (
             (VCS !== 1'b1) ||
             (VSS !== 1'b0)
            // ||
            // ((VBN !== 1'b0) && (VBN !== 1'b1)) ||
            // ((VBP !== 1'b0) && (VBP !== 1'b1))
            )
           begin
              if (!killArray[KA_VOLT]) begin
                 ERROR_TASK(MSG_VOLT, "Voltage supplies are not at correct level. Array contents are now invalid.");
                 //killData[KD_VOLT] = 0;
                 killArray[KA_VOLT] = 1;
              end
           end

         else begin

            // We can only get here if VCS, VSS, VBN, and VBP are valid

            //if (VDD !== 1'b1) begin
            if ( (VDD !== 1'b1) || ((VBN !== 1'b0) && (VBN !== 1'b1)) || ((VBP !== 1'b0) && (VBP !== 1'b1)) ) begin

               // Using killArray and killData here because we can only enter UCR1 mode from powered-up mode.
               if (!killArray[KA_VOLT] && !killData[KD_VOLT] && (powergateI === 1'b0) && (deepsleepI === 1'b0)) begin
                  WARNING_TASK(MSG_VOLT, "Entering User Controlled Retention 1 (UCR1) mode. Output Q are now invalid.");
                  killData[KD_VOLT] = 1;
               end

               else begin
                  if (!killArray[KA_VOLT]) begin
                     ERROR_TASK(MSG_VOLT, "Voltage supplies are not at correct level. Array contents are now invalid.");
                     //killData[KD_VOLT] = 0;
                     killArray[KA_VOLT] = 1;
                  end
               end

            end

            else begin
               if ( (VDD === 1'b1) && ((VBN === 1'b0) || (VBN === 1'b1)) && ((VBP === 1'b0) || (VBP === 1'b1)) ) begin
                  killData[KD_VOLT] = 0;
                  killArray[KA_VOLT] = 0;
               end
            end

         end
      end
   end
 `endif //  `ifdef IVCS_PG

   //Timing check notifier
   always @(notifier) begin
      if (startTrigger && !killArray[KA_TMG]) begin
//       killFlag = 0; // This will ensure that timing violations are not masked
         killArray[KA_TMG] = 1;   //No messaging (rely on specify messaging for timing issues)
      end
   end

   //Deepsleep/Powergate check
 `ifndef IVCS_PGDS_DELAYCHK

   //Normal no-op clock counting check
   localparam integer PG_WKUP_CNT = (PG_TO_CEN > CYCLE_TIME) ? (PG_TO_CEN/CYCLE_TIME)-1 : 0;
   localparam integer DS_WKUP_CNT = (DS_TO_CEN > CYCLE_TIME) ? (DS_TO_CEN/CYCLE_TIME)-1 : 0;

   localparam PMODE_START_STATE  = 3'b000;
   localparam PMODE_ENABLE_STATE = 3'b001;
   localparam PMODE_DS_STATE     = 3'b010;
   localparam PMODE_PG_STATE     = 3'b011;
   localparam PMODE_DSEXIT_STATE = 3'b100;
   localparam PMODE_PGEXIT_STATE = 3'b101;
   localparam PMODE_ERROR_STATE  = 3'b110;

   reg [2:0] n_pModeFSM;
   reg [2:0] r_pModeFSM;
   reg       n_pModeStart;
   reg       n_pModeDSexit;
   reg       n_pModePGexit;
   reg       n_pModeError;
   reg       n_pModeEnable;

   always @ (*) begin
      n_pModeStart = 0;
      n_pModeDSexit = 0;
      n_pModePGexit = 0;
      n_pModeError = 0;
      n_pModeEnable = 0;

      // Allow model to be "powered-up" with DEEPSLEEP asserted
      if (!startTrigger && !t_logic && cenI && deepsleepI && !powergateI) begin
         n_pModeFSM = PMODE_DS_STATE;
      end
      // Allow model to be "powered-up" with POWERGATE asserted
      else if (!startTrigger && !t_logic && cenI && !deepsleepI && powergateI) begin
         n_pModeFSM = PMODE_PG_STATE;
      end
      else if (!startTrigger || t_logic) begin
         n_pModeFSM = PMODE_START_STATE;
      end
      else begin
         case (r_pModeFSM)

           PMODE_START_STATE :
             begin
                n_pModeStart = 1;
                if (deepsleepI || powergateI)                 n_pModeFSM = PMODE_ERROR_STATE;
                else if (cenI && !deepsleepI && !powergateI)  n_pModeFSM = PMODE_ENABLE_STATE;
                else                                          n_pModeFSM = PMODE_START_STATE;
             end

           PMODE_ENABLE_STATE :
             begin
                n_pModeEnable = 1;
                if (!cenI && (deepsleepI || powergateI))      n_pModeFSM = PMODE_ERROR_STATE;
                else if (cenI && deepsleepI && !powergateI)   n_pModeFSM = PMODE_DS_STATE;
                else if (cenI && !deepsleepI && powergateI)   n_pModeFSM = PMODE_PG_STATE;
                else if (!cenI && !deepsleepI && !powergateI) n_pModeFSM = PMODE_START_STATE;
                else                                          n_pModeFSM = PMODE_ENABLE_STATE;
             end

           PMODE_DS_STATE :
             begin
                if (!cenI || powergateI)                      n_pModeFSM = PMODE_ERROR_STATE;
                else if (cenI && !deepsleepI && !powergateI)  n_pModeFSM = PMODE_DSEXIT_STATE;
                else                                          n_pModeFSM = PMODE_DS_STATE;
             end

           PMODE_PG_STATE :
             begin
                if (!cenI || deepsleepI)                      n_pModeFSM = PMODE_ERROR_STATE;
                else if (cenI && !deepsleepI && !powergateI)  n_pModeFSM = PMODE_PGEXIT_STATE;
                else                                          n_pModeFSM = PMODE_PG_STATE;
             end

           PMODE_DSEXIT_STATE :
             begin
                n_pModeDSexit = 1;
                if (cenI && !deepsleepI && !powergateI) begin
                   if (cnt < DS_WKUP_CNT)                     n_pModeFSM = PMODE_DSEXIT_STATE;
                   else                                       n_pModeFSM = PMODE_START_STATE;
                end
                else                                          n_pModeFSM = PMODE_ERROR_STATE;
             end

           PMODE_PGEXIT_STATE :
             begin
                n_pModePGexit = 1;
                if (cenI && !deepsleepI && !powergateI) begin
                   if (cnt < PG_WKUP_CNT)                     n_pModeFSM = PMODE_PGEXIT_STATE;
                   else                                       n_pModeFSM = PMODE_START_STATE;
                end
                else                                          n_pModeFSM = PMODE_ERROR_STATE;
             end

           PMODE_ERROR_STATE :
             begin
                n_pModeError = 1;
                if (cenI && !deepsleepI && !powergateI) begin
                   if (cnt < DS_WKUP_CNT)                     n_pModeFSM = PMODE_ERROR_STATE;
                   else                                       n_pModeFSM = PMODE_START_STATE;
                end
                else                                          n_pModeFSM = PMODE_ERROR_STATE;
             end

           default :
             begin
                if (deepsleepI || powergateI)                 n_pModeFSM = PMODE_ERROR_STATE;
                else if (cenI && !deepsleepI && !powergateI)  n_pModeFSM = PMODE_ENABLE_STATE;
                else                                          n_pModeFSM = PMODE_START_STATE;
             end

         endcase
      end
   end

   //If ds/pg are high for any point in time during start state then fail OR if they are ever BOTH high then fail
   wire pModeGlitch = ((n_pModeStart) & (deepsleepI | powergateI)) | (deepsleepI & powergateI);

   always @(posedge clkI or pModeGlitch) begin
      if (pModeGlitch) begin
         r_pModeFSM <= PMODE_ERROR_STATE;
      end
      else begin
         r_pModeFSM <= n_pModeFSM;
      end
   end

   assign pModeFatal = n_pModeError & ~t_logic & ~TESTCHIP_wire;

   always @(posedge clkI) begin
      if (n_pModeDSexit || n_pModePGexit || n_pModeError) begin
         if ((n_pModeError && cenI && !deepsleepI && !powergateI) || n_pModeDSexit || n_pModePGexit) begin
            cnt <= cnt + 1;
         end
      end
      else begin
         cnt <= 0;
      end
   end
 `else

   //Method using delays (handles case where memory clock is gated)
   wire cenD;
   wire powergateD;
   wire deepsleepD;

   assign #CYCLE_TIME cenD = cenI;
   assign #PG_TO_CEN powergateD = powergateI;
   assign #DS_TO_CEN deepsleepD = deepsleepI;

   wire pModeGlitch = (deepsleepI & powergateI);

   wire pModeError = (~cenD & powergateI) | ((powergateD===1'b1) & ~cenI) | (powergateI & ~cenI) |
                     (~cenD & deepsleepI) | ((deepsleepD===1'b1) & ~cenI) | (deepsleepI & ~cenI);

   assign pModeFatal = (pModeError | pModeGlitch) & ~t_logic & ~TESTCHIP_wire;

 `endif // !`ifndef IVCS_PGDS_DELAYCHK

 `ifndef IVCS_FAST_FUNC
   ////////////////////////////////////////////////////
   // BL redundancy
   ////////////////////////////////////////////////////

   reg [D_SIZE-1:0] rblMuxSel [3:0];
   reg [7:0]        i, j;

   always @(*) begin

      rblMuxSel[0] = 0;
      rblMuxSel[1] = 0;
      rblMuxSel[2] = 0;
      rblMuxSel[3] = 0;

      if(rbeI[0]) begin

         j=0;
         for(i=0; i<(SEG0_SIZE*MUX/4); i=i+1) begin

            if(i<rbfI[0]) rblMuxSel[0][j] = 1'b0;
            else          rblMuxSel[0][j] = 1'b1;

            if(MUX>=8) begin
               i=i+1;
               if(i<rbfI[0]) rblMuxSel[1][j] = 1'b0;
               else          rblMuxSel[1][j] = 1'b1;
            end

            if(MUX>=16) begin
               i=i+1;
               if(i<rbfI[0]) rblMuxSel[2][j] = 1'b0;
               else          rblMuxSel[2][j] = 1'b1;
               i=i+1;
               if(i<rbfI[0]) rblMuxSel[3][j] = 1'b0;
               else          rblMuxSel[3][j] = 1'b1;
            end

            j=j+1;

         end

      end

      if ((NUM_SEG>1) && rbeI[1]) begin

         j=SEG1_LSB;
         for(i=0; i<(SEG1_SIZE*MUX/4); i=i+1) begin

            if(i<rbfI[1]) rblMuxSel[0][j] = 1'b0;
            else          rblMuxSel[0][j] = 1'b1;

            if(MUX>=8) begin
               i=i+1;
               if(i<rbfI[1]) rblMuxSel[1][j] = 1'b0;
               else          rblMuxSel[1][j] = 1'b1;
            end

            if(MUX>=16) begin
               i=i+1;
               if(i<rbfI[1]) rblMuxSel[2][j] = 1'b0;
               else          rblMuxSel[2][j] = 1'b1;
               i=i+1;
               if(i<rbfI[1]) rblMuxSel[3][j] = 1'b0;
               else          rblMuxSel[3][j] = 1'b1;
            end

            j=j+1;

         end

      end

   end
 `endif

   ////////////////////////////////////////////////////
   // Array read/write modeling
   ////////////////////////////////////////////////////

   // Check that the clock is good
   always @(clk) begin

      iClk = (clk^clk)^(clk&~oldClk);

      if ((killArray[KA_CLK]!==1'b1) && (iClk!==1'b1) && (iClk!==1'b0)) begin
         ERROR_TASK(MSG_CLK, "CLK input is unknown. Array contents are now invalid.");
         killArray[KA_CLK] = 1;
         clkGate = 1'b0;
      end

      else begin
         killArray[KA_CLK] = 0;
         if (!clk) begin
            clkGate = 1'b1;
            if (startTrigger!==1'b1) begin
               // We reset all this stuff the first time the clock is stable
               msgTrigger = 0;
               porTrigger = 0;
               dsTrigger = 0;
               killArray = 0;
               killFlag = 0;
               killData = 0;
               killDataFlag = 0;
               cnt = 0;
               if(PreloadArrayBinFile != "NONE") LoadArrayFromBinFile(PreloadArrayBinFile);
               if(PreloadArrayHexFile != "NONE") LoadArrayFromHexFile(PreloadArrayHexFile);
               startTrigger <= 1'b1;
            end
         end
      end

      oldClk = clk;

   end // always @(clk)


   // This code block defines synchronous read/write operations
   assign clkI = clkGate & clk;
   assign killDataOR = |killData;
   assign killArrayOR = |killArray;

   always @(posedge clkI or posedge killDataOR or posedge killArrayOR or posedge dsTrigger) begin

      // Clear these killData triggers at the beginning of each cycle
      if (killDataFlag) begin
         killData[KD_RX] = 0;
         killData[KD_STAB] = 0;
 `ifndef IVCS_PG
         killData[KD_VOLT] = 0;
 `endif
         killDataFlag = 0;
      end

      // Clear just these killArray triggers at the beginning of each cycle
      // (the others are self-clearing)
      if (killFlag) begin
         killArray[KA_MA]  = 0;
         killArray[KA_RX]  = 0;
         killArray[KA_TMG] = 0;
 `ifndef IVCS_PG
         killArray[KA_VOLT] = 0;
 `endif
      end

      if (t_logic===1'b1) begin
         array_data     = (dI & bwI) | (~dI & ~bwI);
 `ifndef IVCS_FAST_FUNC
         array_red_data = 2'bxx;
 `endif
      end

      else if (|killData) begin
         // If killDataOR is on, assume it's because of (posedge killDataOR)
         array_data = {D_SIZE{1'bx}};
 `ifndef IVCS_FAST_FUNC
         array_red_data = 2'bxx;
 `endif
         killDataFlag = 1;
      end

      else if (|killArray || dsTrigger) begin
         // We will enter this block because of (posedge killArrayOR),
         // or because of (posege clkI) and killArrayOR is still on.
         // In the latter case, the killFlag will prevent us from
         // needlessly X-ing the array every cycle while the
         // killArray condition persists.
         if(|killArray) begin
            array_data = {D_SIZE{1'bx}};
 `ifndef IVCS_FAST_FUNC
            array_red_data = 2'bxx;
 `endif
         end
         if(!killFlag) begin
            BlanketWriteArray(1'bx);
            killFlag = 1;
         end
      end

      else begin

         // If we get here, it's because of (posedge clkI) and no killArray condition exists

         // If t_logic or DEEPSLEEP or POWERGATE is on, we don't do anything
         if (!t_logic && !deepsleepI && !powergateI) begin

            // When cen is unknown
            if ((cenI!==1'b0) && (cenI!==1'b1)) begin
               ERROR_TASK(MSG_IOK, "CEN or T_CEN input is unknown. Array contents and output Q are now invalid.");
               array_data = {D_SIZE{1'bx}};
 `ifndef IVCS_FAST_FUNC
               array_red_data = 2'bxx;
 `endif
               if(!killFlag) begin
                  BlanketWriteArray(1'bx);
                  killFlag = 1;
               end
            end

            // If cen is not unknown, but simply deasserted (high), we don't do anything
            else if (!cenI) begin

               // When write enable is unknown
               if ((rdwenI!==1'b0) && (rdwenI!==1'b1)) begin
                  ERROR_TASK(MSG_IOK, "RDWEN or T_RDWEN is unknown. Array contents and output Q are now invalid.");
                  array_data = {D_SIZE{1'bx}};
 `ifndef IVCS_FAST_FUNC
                  array_red_data = 2'bxx;
 `endif
                  if (!killFlag) begin
                     BlanketWriteArray(1'bx);
                     killFlag = 1;
                  end
               end

               // When one or more address bits is unknown (write mode)
               else if (!rdwenI && (^{asI, awI, acI}!==1'b0) && (^{asI, awI, acI}!==1'b1)) begin
                  ERROR_TASK(MSG_IOK, "One or more ADDRESS inputs is unknown during a write. Array contents are now invalid.");
                  if (!killFlag) begin
                     BlanketWriteArray(1'bx);
                     killFlag = 1;
                  end
               end

               // When one or more address bits is unknown (read mode)
               else if (rdwenI && (^{asI, awI, acI}!==1'b0) && (^{asI, awI, acI}!==1'b1)) begin
                  ERROR_TASK(MSG_IOK, "One or more ADDRESS inputs is unknown during a read. Output Q are now invalid.");
                  array_data = {D_SIZE{1'bx}};
 `ifndef IVCS_FAST_FUNC
                  array_red_data = 2'bxx;
 `endif
               end

               else begin
                  // Finally... Time to read/write the array
                  ReadOrWriteArray(rdwenI, asI, awI, acI, bwI, dI);
                  killFlag = 0;
               end

            end // if (!cenI)
         end // if (!t_logic && !deepsleepI && !powergateI)
      end // else: !if(|killArray || dsTrigger)
   end // always @(posedge clkI or posedge killArrayOR...

`ifdef IVCS_INIT_MEM
   ////////////////////////////////////////////////////
   // Handle INIT_MEM behavior
   ////////////////////////////////////////////////////

   wire IVCS_INIT_MEM_wire = 1'b0;
   initial #0.1 InitMem;
   always @(posedge IVCS_INIT_MEM_wire) InitMem;
   task InitMem;
      begin
         BlanketWriteArray(1'b0);
         array_data     <= {D_SIZE{1'b0}};
         array_red_data <= 2'b00;
         data_l1        <= {D_SIZE{1'b0}};
         red_data_l1    <= 2'b00;
         data_l2        <= {D_SIZE{1'b0}};
         red_data_l2    <= 2'b00;
      end
   endtask
`endif

   ////////////////////////////////////////////////////
   // Output latch modeling
   ////////////////////////////////////////////////////

   always @(*) data_l1     <= array_data;
`ifndef IVCS_FAST_FUNC
   always @(*) red_data_l1 <= array_red_data;
`endif

   // Output pipeline flop for non-flowthru memories
   always @(posedge clk or posedge killDataOR or posedge killArrayOR) begin
      if(killDataOR || killArrayOR) begin
         data_l2     <= {D_SIZE{1'bx}};
 `ifndef IVCS_FAST_FUNC
         red_data_l2 <= 2'bxx;
 `endif
      end
      else begin
//       data_l2     <= array_data;
         data_l2     <= data_l1;
 `ifndef IVCS_FAST_FUNC
//       red_data_l2 <= array_red_data;
         red_data_l2 <= red_data_l1;
 `endif
      end
   end

   // Generate outputs
// assign q =   pipeline ? data_l2     : array_data;
   assign q =   pipeline ? data_l2     : data_l1;
 `ifndef IVCS_FAST_FUNC
// assign qrb = pipeline ? red_data_l2 : array_red_data;
   assign qrb = pipeline ? red_data_l2 : red_data_l1;
 `else
   assign qrb = 0;
 `endif



   ////////////////////////////////////////////////////////////////////////////
   ////////////////////////////////////////////////////////////////////////////
   // Supporting functions and tasks
   ////////////////////////////////////////////////////////////////////////////
   ////////////////////////////////////////////////////////////////////////////


   ////////////////////////////////////////////////////////////////////////////
   // Array reads/writes go through this task
   ////////////////////////////////////////////////////////////////////////////

   // Note: In order to support the BW function, this task always does
   //       a read then write regardless of the state of rdwen.
   //       If rdwen=0, the read data won't be propagated to the Q bus.

   task ReadOrWriteArray;

      input                i_rdwen;
      input [AS_SIZE-1:0]  i_as;
      input [AW_SIZE-1:0]  i_aw;
      input [AC_SIZE-1:0]  i_ac;
      input [D_SIZE-1:0]   i_bw;
      input [D_SIZE-1:0]   i_d;

      // Local regs - prepend with "my_" so I can tell them
      // apart from the handful of globals
      reg                  my_oob_address;
      reg [A_SIZE :0]      my_arrayAddr;
      reg [A_SIZE :0]      my_arrayAddr2;
      reg [D_SIZE-1:0]     my_data;
      reg [D_SIZE-1:0]     my_w_data;
      reg [3:0]            my_ac;
 `ifndef IVCS_FAST_FUNC
      reg [A_SIZE :0]      my_rblAddr;
      reg [1:0]            my_red_data;
      reg [D_SIZE-1:0]     my_rblMuxSel;
 `endif

      begin

         if ( {i_aw[AW_SIZE-1:2], i_as, i_aw[1:0], i_ac} >= W_DEPTH ) begin
            my_oob_address = 1'b1;
         end
         else begin
            my_oob_address = 1'b0;
         end

         if (my_oob_address) begin
            if(!i_rdwen) begin
               WARNING_TASK(MSG_OOB, { "Write address (Sub=", str(i_as), ", Row=", str(i_aw), ", Col=", str(i_ac), ") is out of bounds for this array size. Array will not be written." });
            end
            else begin
               WARNING_TASK(MSG_OOB, {  "Read address (Sub=", str(i_as), ", Row=", str(i_aw), ", Col=", str(i_ac), ") is out of bounds for this array size. Output Q are now invalid." });
            end
         end

         if (i_rdwen && !readOK) begin
            WARNING_TASK(MSG_RD, "MA inputs at incorrect values during read. Output Q are now invalid.");
         end

         // Trash the Q data if invalid read
         if (i_rdwen && (my_oob_address || !readOK)) begin
            array_data = {D_SIZE{1'bx}};
 `ifndef IVCS_FAST_FUNC
            array_red_data = 2'bxx;
 `endif
         end

         // Condition for a valid read or write
         if (!my_oob_address && (!i_rdwen || (i_rdwen && readOK))) begin

 `ifdef IVCS_FAST_FUNC
            my_arrayAddr = { i_aw[AW_SIZE-1:2], i_as, i_aw[1:0], i_ac };
            my_data = array[my_arrayAddr];
            if (i_rdwen) begin
               array_data = my_data;
            end
            else begin
               array[my_arrayAddr] = (i_bw & i_d) | (~i_bw & my_data);
            end
 `else
            // Inject any fails before doing the read
            if (any_fail) ForceFails;

            // Address manipulations if row redundancy is invoked
            if (rweI[0] && (rwfI[0]==(i_aw>>1))) begin
               my_arrayAddr = W_DEPTH + { i_as, 1'b0, i_aw[0], i_ac };
               my_rblAddr   = W_DEPTH + { i_as, 1'b0, i_aw[0], i_ac[1:0] };
            end
            else if (rweI[1] && (rwfI[1]==(i_aw>>1))) begin
               my_arrayAddr = W_DEPTH + { i_as, 1'b1, i_aw[0], i_ac };
               my_rblAddr   = W_DEPTH + { i_as, 1'b1, i_aw[0], i_ac[1:0] };
            end
            else begin
               my_arrayAddr = { i_aw[AW_SIZE-1:2], i_as, i_aw[1:0], i_ac };
               my_rblAddr   = { i_aw[AW_SIZE-1:2], i_as, i_aw[1:0], i_ac[1:0] };
            end

            // Get the RBL data
            my_red_data = arrayRBL[my_rblAddr];

            // Do this to avoid part-select out of range warnings
            my_ac = 4'd0;
            my_ac[AC_SIZE-1:0] = i_ac;

            // Work on segment 0
            if (!rbeI[0]) begin
               my_data[SEG0_MSB:0] = array[my_arrayAddr][SEG0_MSB:0];
            end
            else begin

               /* This way makes sense from a physical array point of view (M16 version
                shown), but it does a lot of computations that just get discarded.
                So use the restructured version below.

                my_arrayBaseAddr = { my_arrayAddr[A_SIZE:AC_SIZE], {AC_SIZE{1'b0}} } + i_ac[1:0];

                my_rblMuxIn0AC0to3[SEG0_MSB:0]   = ~rblMuxSelAC0to3[SEG0_MSB:0]   & array[my_arrayBaseAddr   ][SEG0_MSB:0];
                my_rblMuxIn1AC0to3[SEG0_MSB:0]   =  rblMuxSelAC0to3[SEG0_MSB:0]   & array[my_arrayBaseAddr+4 ][SEG0_MSB:0];
                my_rblMuxIn0AC4to7[SEG0_MSB:0]   = ~rblMuxSelAC4to7[SEG0_MSB:0]   & array[my_arrayBaseAddr+4 ][SEG0_MSB:0];
                my_rblMuxIn1AC4to7[SEG0_MSB:0]   =  rblMuxSelAC4to7[SEG0_MSB:0]   & array[my_arrayBaseAddr+8 ][SEG0_MSB:0];
                my_rblMuxIn0AC8to11[SEG0_MSB:0]  = ~rblMuxSelAC8to11[SEG0_MSB:0]  & array[my_arrayBaseAddr+8 ][SEG0_MSB:0];
                my_rblMuxIn1AC8to11[SEG0_MSB:0]  =  rblMuxSelAC8to11[SEG0_MSB:0]  & array[my_arrayBaseAddr+12][SEG0_MSB:0];
                my_rblMuxIn0AC12to15[SEG0_MSB:0] = ~rblMuxSelAC12to15[SEG0_MSB:0] & array[my_arrayBaseAddr+12][SEG0_MSB:0];
                my_rblMuxIn1AC12to15[SEG0_MSB:0] =  rblMuxSelAC12to15[SEG0_MSB:0] & { arrayRBL[my_rblAddr][0], array[my_arrayBaseAddr][SEG0_MSB:0] };

                my_rblMuxOutAC0to3   = my_rblMuxIn0AC0to3[SEG0_MSB:0]   | my_rblMuxIn1AC0to3[SEG0_MSB:0];
                my_rblMuxOutAC4to7   = my_rblMuxIn0AC4to7[SEG0_MSB:0]   | my_rblMuxIn1AC4to7[SEG0_MSB:0];
                my_rblMuxOutAC8to11  = my_rblMuxIn0AC8to11[SEG0_MSB:0]  | my_rblMuxIn1AC8to11[SEG0_MSB:0];
                my_rblMuxOutAC12to15 = my_rblMuxIn0A120to15[SEG0_MSB:0] | my_rblMuxIn1AC12to15[SEG0_MSB:0];

                if ((i_ac>>2)==0) my_data[SEG0_MSB:0] = my_rblMuxOutAC0to3[SEG0_MSB:0];
                if ((i_ac>>2)==1) my_data[SEG0_MSB:0] = my_rblMuxOutAC4to7[SEG0_MSB:0];
                if ((i_ac>>2)==2) my_data[SEG0_MSB:0] = my_rblMuxOutAC8to11[SEG0_MSB:0];
                if ((i_ac>>2)==3) my_data[SEG0_MSB:0] = my_rblMuxOutAC12to15[SEG0_MSB:0];
                */

               if (MUX==4) begin
                  my_data[SEG0_MSB:0] = (~rblMuxSel[0][SEG0_MSB:0] & array[my_arrayAddr][SEG0_MSB:0]) |
                                        ( rblMuxSel[0][SEG0_MSB:0] & {my_red_data[0], array[my_arrayAddr][SEG0_MSB:1]});
               end
               if (MUX==8) begin
                  if (my_ac[2]==0) begin
                     my_data[SEG0_MSB:0] = (~rblMuxSel[0][SEG0_MSB:0] & array[my_arrayAddr  ][SEG0_MSB:0]) |
                                           ( rblMuxSel[0][SEG0_MSB:0] & array[my_arrayAddr+4][SEG0_MSB:0]);
                  end
                  if (my_ac[2]==1) begin
                     my_arrayAddr2 = {my_arrayAddr[A_SIZE:3], 1'b0, my_arrayAddr[1:0]};
                     my_data[SEG0_MSB:0] = (~rblMuxSel[1][SEG0_MSB:0] & array[my_arrayAddr][SEG0_MSB:0]) |
                                           ( rblMuxSel[1][SEG0_MSB:0] & {my_red_data[0], array[my_arrayAddr2][SEG0_MSB:1]});
                  end
               end
               if (MUX==16) begin
                  if (my_ac[3:2]==0) begin
                     my_data[SEG0_MSB:0] = (~rblMuxSel[0][SEG0_MSB:0] & array[my_arrayAddr  ][SEG0_MSB:0]) |
                                           ( rblMuxSel[0][SEG0_MSB:0] & array[my_arrayAddr+4][SEG0_MSB:0]);
                  end
                  if (my_ac[3:2]==1) begin
                     my_data[SEG0_MSB:0] = (~rblMuxSel[1][SEG0_MSB:0] & array[my_arrayAddr  ][SEG0_MSB:0]) |
                                           ( rblMuxSel[1][SEG0_MSB:0] & array[my_arrayAddr+4][SEG0_MSB:0]);
                  end
                  if (my_ac[3:2]==2) begin
                     my_data[SEG0_MSB:0] = (~rblMuxSel[2][SEG0_MSB:0] & array[my_arrayAddr  ][SEG0_MSB:0]) |
                                           ( rblMuxSel[2][SEG0_MSB:0] & array[my_arrayAddr+4][SEG0_MSB:0]);
                  end
                  if (my_ac[3:2]==3) begin
                     my_arrayAddr2 = {my_arrayAddr[A_SIZE:4], 2'b00, my_arrayAddr[1:0]};
                     my_data[SEG0_MSB:0] = (~rblMuxSel[3][SEG0_MSB:0] & array[my_arrayAddr][SEG0_MSB:0]) |
                                           ( rblMuxSel[3][SEG0_MSB:0] & {my_red_data[0], array[my_arrayAddr2][SEG0_MSB:1]});
                  end
               end
            end // else: !if(!rbeI[0])

            // Work on segment 1
            if (NUM_SEG>1) begin
               if (!rbeI[1]) begin
                  my_data[SEG1_MSB:SEG1_LSB] = array[my_arrayAddr][SEG1_MSB:SEG1_LSB];
               end
               else begin
                  if (MUX==4) begin
                     my_data[SEG1_MSB:SEG1_LSB] = (~rblMuxSel[0][SEG1_MSB:SEG1_LSB] & array[my_arrayAddr][SEG1_MSB:SEG1_LSB]) |
                                                  ( rblMuxSel[0][SEG1_MSB:SEG1_LSB] & {my_red_data[1], array[my_arrayAddr][SEG1_MSB:SEG1_LSB+1]});
                  end
                  if (MUX==8) begin
                     if (my_ac[2]==0) begin
                        my_data[SEG1_MSB:SEG1_LSB] = (~rblMuxSel[0][SEG1_MSB:SEG1_LSB] & array[my_arrayAddr  ][SEG1_MSB:SEG1_LSB]) |
                                                     ( rblMuxSel[0][SEG1_MSB:SEG1_LSB] & array[my_arrayAddr+4][SEG1_MSB:SEG1_LSB]);
                     end
                     if (my_ac[2]==1) begin
                        my_arrayAddr2 = {my_arrayAddr[A_SIZE:3], 1'b0, my_arrayAddr[1:0]};
                        my_data[SEG1_MSB:SEG1_LSB] = (~rblMuxSel[1][SEG1_MSB:SEG1_LSB] & array[my_arrayAddr][SEG1_MSB:SEG1_LSB]) |
                                                     ( rblMuxSel[1][SEG1_MSB:SEG1_LSB] & {my_red_data[1], array[my_arrayAddr2][SEG1_MSB:SEG1_LSB+1]});
                     end
                  end
                  if (MUX==16) begin
                     if (my_ac[3:2]==0) begin
                        my_data[SEG1_MSB:SEG1_LSB] = (~rblMuxSel[0][SEG1_MSB:SEG1_LSB] & array[my_arrayAddr  ][SEG1_MSB:SEG1_LSB]) |
                                                     ( rblMuxSel[0][SEG1_MSB:SEG1_LSB] & array[my_arrayAddr+4][SEG1_MSB:SEG1_LSB]);
                     end
                     if (my_ac[3:2]==1) begin
                        my_data[SEG1_MSB:SEG1_LSB] = (~rblMuxSel[1][SEG1_MSB:SEG1_LSB] & array[my_arrayAddr  ][SEG1_MSB:SEG1_LSB]) |
                                                     ( rblMuxSel[1][SEG1_MSB:SEG1_LSB] & array[my_arrayAddr+4][SEG1_MSB:SEG1_LSB]);
                     end
                     if (my_ac[3:2]==2) begin
                        my_data[SEG1_MSB:SEG1_LSB] = (~rblMuxSel[2][SEG1_MSB:SEG1_LSB] & array[my_arrayAddr  ][SEG1_MSB:SEG1_LSB]) |
                                                     ( rblMuxSel[2][SEG1_MSB:SEG1_LSB] & array[my_arrayAddr+4][SEG1_MSB:SEG1_LSB]);
                     end
                     if (my_ac[3:2]==3) begin
                        my_arrayAddr2 = {my_arrayAddr[A_SIZE:4], 2'b00, my_arrayAddr[1:0]};
                        my_data[SEG1_MSB:SEG1_LSB] = (~rblMuxSel[3][SEG1_MSB:SEG1_LSB] & array[my_arrayAddr][SEG1_MSB:SEG1_LSB]) |
                                                     ( rblMuxSel[3][SEG1_MSB:SEG1_LSB] & {my_red_data[1], array[my_arrayAddr2][SEG1_MSB:SEG1_LSB+1]});
                     end
                  end
               end // else: !if(!rbeI[1])
            end // if (NUM_SEG>1)

            // If reading, make my data real
            if (i_rdwen) begin
               array_data     = my_data;
               array_red_data = my_red_data;
            end

            // If not reading, we're writing
            else begin

               // The write data
               my_w_data = (i_bw & i_d) | (~i_bw & my_data);

               if (!rbeI[0]) begin
                  array[my_arrayAddr][SEG0_MSB:0] = my_w_data[SEG0_MSB:0];
                  // RBL gets written if tbist is on
                  if (t_bist && i_bw[SEG0_MSB]) begin
                     arrayRBL[my_rblAddr][0] = i_d[SEG0_MSB];
                  end
               end
               else begin
                  // Now we more-or-less reverse the process from above
                  if (MUX==4) begin
                     array[my_arrayAddr][SEG0_MSB:0] = ( rblMuxSel[0][SEG0_MSB:0] & array[my_arrayAddr][SEG0_MSB:0]) |
                                                       (~rblMuxSel[0][SEG0_MSB:0] & my_w_data[SEG0_MSB:0]);

                     arrayRBL[my_rblAddr][0]         = (~rblMuxSel[0][SEG0_MSB] & arrayRBL[my_rblAddr][0]) |
                                                       ( rblMuxSel[0][SEG0_MSB] & my_w_data[SEG0_MSB]);

                     array[my_arrayAddr][SEG0_MSB:1] = (~rblMuxSel[0][SEG0_MSB:1] & array[my_arrayAddr][SEG0_MSB:1]) |
                                                       ( rblMuxSel[0][SEG0_MSB:1] & my_w_data[SEG0_MSB-1:0]);
                  end
                  if (MUX==8) begin
                     if(my_ac[2]==1'd0) begin
                        array[my_arrayAddr  ][SEG0_MSB:0] = ( rblMuxSel[0][SEG0_MSB:0] & array[my_arrayAddr][SEG0_MSB:0]) |
                                                            (~rblMuxSel[0][SEG0_MSB:0] & my_w_data[SEG0_MSB:0]);

                        // Need to account for an adjacency situation where the data bit in the vicinity
                        // of the RBF address gets written to both the unsteered and the steered column address
                        if (rbfI[0][0]==1'd1) my_rblMuxSel[SEG0_MSB:0] = rblMuxSel[1][SEG0_MSB:0];
                        else                  my_rblMuxSel[SEG0_MSB:0] = rblMuxSel[0][SEG0_MSB:0];

                        array[my_arrayAddr+4][SEG0_MSB:0] = (~my_rblMuxSel[SEG0_MSB:0] & array[my_arrayAddr+4][SEG0_MSB:0]) |
                                                            ( my_rblMuxSel[SEG0_MSB:0] & my_w_data[SEG0_MSB:0]);
                     end
                     if(my_ac[2]==1'd1) begin
                        array[my_arrayAddr  ][SEG0_MSB:0] = ( rblMuxSel[1][SEG0_MSB:0] & array[my_arrayAddr][SEG0_MSB:0]) |
                                                            (~rblMuxSel[1][SEG0_MSB:0] & my_w_data[SEG0_MSB:0]);

                        arrayRBL[my_rblAddr][0]           = (~rblMuxSel[1][SEG0_MSB] & arrayRBL[my_rblAddr][0]) |
                                                            ( rblMuxSel[1][SEG0_MSB] & my_w_data[SEG0_MSB]);

                        if (rbfI[0][0]==1'd0) my_rblMuxSel[SEG0_MSB:0] = rblMuxSel[1][SEG0_MSB:0];
                        else                  my_rblMuxSel[SEG0_MSB:0] = rblMuxSel[0][SEG0_MSB:0];

                        array[my_arrayAddr2][SEG0_MSB:1]  = (~my_rblMuxSel[SEG0_MSB:1] & array[my_arrayAddr2][SEG0_MSB:1]) |
                                                            ( my_rblMuxSel[SEG0_MSB:1] & my_w_data[SEG0_MSB-1:0]);
                     end
                  end
                  if (MUX==16) begin
                     if(my_ac[3:2]==2'd0) begin
                        array[my_arrayAddr  ][SEG0_MSB:0] = ( rblMuxSel[0][SEG0_MSB:0] & array[my_arrayAddr][SEG0_MSB:0]) |
                                                            (~rblMuxSel[0][SEG0_MSB:0] & my_w_data[SEG0_MSB:0]);

                        if (rbfI[0][1:0]==2'd1) my_rblMuxSel[SEG0_MSB:0] = rblMuxSel[1][SEG0_MSB:0];
                        else                    my_rblMuxSel[SEG0_MSB:0] = rblMuxSel[0][SEG0_MSB:0];

                        array[my_arrayAddr+4][SEG0_MSB:0] = (~my_rblMuxSel[SEG0_MSB:0] & array[my_arrayAddr+4][SEG0_MSB:0]) |
                                                            ( my_rblMuxSel[SEG0_MSB:0] & my_w_data[SEG0_MSB:0]);
                     end
                     if(my_ac[3:2]==2'd1) begin
                        array[my_arrayAddr  ][SEG0_MSB:0] = ( rblMuxSel[1][SEG0_MSB:0] & array[my_arrayAddr][SEG0_MSB:0]) |
                                                            (~rblMuxSel[1][SEG0_MSB:0] & my_w_data[SEG0_MSB:0]);

                        if (rbfI[0][1:0]==2'd2) my_rblMuxSel[SEG0_MSB:0] = rblMuxSel[2][SEG0_MSB:0];
                        else                    my_rblMuxSel[SEG0_MSB:0] = rblMuxSel[1][SEG0_MSB:0];

                        array[my_arrayAddr+4][SEG0_MSB:0] = (~my_rblMuxSel[SEG0_MSB:0] & array[my_arrayAddr+4][SEG0_MSB:0]) |
                                                            ( my_rblMuxSel[SEG0_MSB:0] & my_w_data[SEG0_MSB:0]);
                     end
                     if(my_ac[3:2]==2'd2) begin
                        array[my_arrayAddr  ][SEG0_MSB:0] = ( rblMuxSel[2][SEG0_MSB:0] & array[my_arrayAddr][SEG0_MSB:0]) |
                                                            (~rblMuxSel[2][SEG0_MSB:0] & my_w_data[SEG0_MSB:0]);

                        if (rbfI[0][1:0]==2'd3) my_rblMuxSel[SEG0_MSB:0] = rblMuxSel[3][SEG0_MSB:0];
                        else                    my_rblMuxSel[SEG0_MSB:0] = rblMuxSel[2][SEG0_MSB:0];

                        array[my_arrayAddr+4][SEG0_MSB:0] = (~my_rblMuxSel[SEG0_MSB:0] & array[my_arrayAddr+4][SEG0_MSB:0]) |
                                                            ( my_rblMuxSel[SEG0_MSB:0] & my_w_data[SEG0_MSB:0]);
                     end
                     if(my_ac[3:2]==2'd3) begin
                        array[my_arrayAddr  ][SEG0_MSB:0] = ( rblMuxSel[3][SEG0_MSB:0] & array[my_arrayAddr][SEG0_MSB:0]) |
                                                            (~rblMuxSel[3][SEG0_MSB:0] & my_w_data[SEG0_MSB:0]);

                        arrayRBL[my_rblAddr][0]           = (~rblMuxSel[3][SEG0_MSB] & arrayRBL[my_rblAddr][0]) |
                                                            ( rblMuxSel[3][SEG0_MSB] & my_w_data[SEG0_MSB]);

                        if (rbfI[0][1:0]==2'd0) my_rblMuxSel[SEG0_MSB:0] = rblMuxSel[3][SEG0_MSB:0];
                        else                    my_rblMuxSel[SEG0_MSB:0] = rblMuxSel[0][SEG0_MSB:0];

                        array[my_arrayAddr2][SEG0_MSB:1]  = (~my_rblMuxSel[SEG0_MSB:1] & array[my_arrayAddr2][SEG0_MSB:1]) |
                                                            ( my_rblMuxSel[SEG0_MSB:1] & my_w_data[SEG0_MSB-1:0]);
                     end
                  end // if (MUX==16)
               end // else: !if(!rbeI[0])

               if (NUM_SEG>1) begin
                  if (!rbeI[1]) begin
                     array[my_arrayAddr][SEG1_MSB:SEG1_LSB] = my_w_data[SEG1_MSB:SEG1_LSB];
                     // RBL always gets written if tbist is on
                     if (t_bist && i_bw[SEG1_MSB]) begin
                        arrayRBL[my_rblAddr][1] = i_d[SEG1_MSB];
                     end
                  end
                  else begin
                     // Now we reverse the process from above
                     if (MUX==4) begin
                        array[my_arrayAddr][SEG1_MSB:SEG1_LSB]   = ( rblMuxSel[0][SEG1_MSB:SEG1_LSB] & array[my_arrayAddr][SEG1_MSB:SEG1_LSB]) |
                                                                   (~rblMuxSel[0][SEG1_MSB:SEG1_LSB] & my_w_data[SEG1_MSB:SEG1_LSB]);

                        arrayRBL[my_rblAddr][1]                  = (~rblMuxSel[0][SEG1_MSB] & arrayRBL[my_rblAddr][1]) |
                                                                   ( rblMuxSel[0][SEG1_MSB] & my_w_data[SEG1_MSB]);

                        array[my_arrayAddr][SEG1_MSB:SEG1_LSB+1] = (~rblMuxSel[0][SEG1_MSB:SEG1_LSB+1] & array[my_arrayAddr][SEG1_MSB:SEG1_LSB+1]) |
                                                                   ( rblMuxSel[0][SEG1_MSB:SEG1_LSB+1] & my_w_data[SEG1_MSB-1:SEG1_LSB]);
                     end
                     if (MUX==8) begin
                        if(my_ac[2]==1'd0) begin
                           array[my_arrayAddr  ][SEG1_MSB:SEG1_LSB]  = ( rblMuxSel[0][SEG1_MSB:SEG1_LSB] & array[my_arrayAddr][SEG1_MSB:SEG1_LSB]) |
                                                                       (~rblMuxSel[0][SEG1_MSB:SEG1_LSB] & my_w_data[SEG1_MSB:SEG1_LSB]);

                           // Need to account for an adjacency situation where the write data in the vicinity
                           // of the RBF address gets written to both the unsteered and the steered column address
                           if (rbfI[1][0]==1'd1) my_rblMuxSel[SEG1_MSB:SEG1_LSB] = rblMuxSel[1][SEG1_MSB:SEG1_LSB];
                           else                  my_rblMuxSel[SEG1_MSB:SEG1_LSB] = rblMuxSel[0][SEG1_MSB:SEG1_LSB];

                           array[my_arrayAddr+4][SEG1_MSB:SEG1_LSB]  = (~my_rblMuxSel[SEG1_MSB:SEG1_LSB] & array[my_arrayAddr+4][SEG1_MSB:SEG1_LSB]) |
                                                                       ( my_rblMuxSel[SEG1_MSB:SEG1_LSB] & my_w_data[SEG1_MSB:SEG1_LSB]);
                        end
                        if(my_ac[2]==1'd1) begin
                           array[my_arrayAddr  ][SEG1_MSB:SEG1_LSB]  = ( rblMuxSel[1][SEG1_MSB:SEG1_LSB] & array[my_arrayAddr][SEG1_MSB:SEG1_LSB]) |
                                                                       (~rblMuxSel[1][SEG1_MSB:SEG1_LSB] & my_w_data[SEG1_MSB:SEG1_LSB]);

                           arrayRBL[my_rblAddr][1]                   = (~rblMuxSel[1][SEG1_MSB] & arrayRBL[my_rblAddr][1]) |
                                                                       ( rblMuxSel[1][SEG1_MSB] & my_w_data[SEG1_MSB]);

                           if (rbfI[1][0]==1'd0) my_rblMuxSel[SEG1_MSB:SEG1_LSB] = rblMuxSel[1][SEG1_MSB:SEG1_LSB];
                           else                  my_rblMuxSel[SEG1_MSB:SEG1_LSB] = rblMuxSel[0][SEG1_MSB:SEG1_LSB];

                           array[my_arrayAddr2][SEG1_MSB:SEG1_LSB+1] = (~my_rblMuxSel[SEG1_MSB:SEG1_LSB+1] & array[my_arrayAddr2][SEG1_MSB:SEG1_LSB+1]) |
                                                                       ( my_rblMuxSel[SEG1_MSB:SEG1_LSB+1] & my_w_data[SEG1_MSB-1:SEG1_LSB]);
                        end
                     end
                     if (MUX==16) begin
                        if(my_ac[3:2]==2'd0) begin
                           array[my_arrayAddr  ][SEG1_MSB:SEG1_LSB]  = ( rblMuxSel[0][SEG1_MSB:SEG1_LSB] & array[my_arrayAddr][SEG1_MSB:SEG1_LSB]) |
                                                                       (~rblMuxSel[0][SEG1_MSB:SEG1_LSB] & my_w_data[SEG1_MSB:SEG1_LSB]);

                           if (rbfI[1][1:0]==2'd1) my_rblMuxSel[SEG1_MSB:SEG1_LSB] = rblMuxSel[1][SEG1_MSB:SEG1_LSB];
                           else                    my_rblMuxSel[SEG1_MSB:SEG1_LSB] = rblMuxSel[0][SEG1_MSB:SEG1_LSB];

                           array[my_arrayAddr+4][SEG1_MSB:SEG1_LSB]  = (~my_rblMuxSel[SEG1_MSB:SEG1_LSB] & array[my_arrayAddr+4][SEG1_MSB:SEG1_LSB]) |
                                                                       ( my_rblMuxSel[SEG1_MSB:SEG1_LSB] & my_w_data[SEG1_MSB:SEG1_LSB]);
                        end
                        if(my_ac[3:2]==2'd1) begin
                           array[my_arrayAddr  ][SEG1_MSB:SEG1_LSB]  = ( rblMuxSel[1][SEG1_MSB:SEG1_LSB] & array[my_arrayAddr][SEG1_MSB:SEG1_LSB]) |
                                                                       (~rblMuxSel[1][SEG1_MSB:SEG1_LSB] & my_w_data[SEG1_MSB:SEG1_LSB]);

                           if (rbfI[1][1:0]==2'd2) my_rblMuxSel[SEG1_MSB:SEG1_LSB] = rblMuxSel[2][SEG1_MSB:SEG1_LSB];
                           else                    my_rblMuxSel[SEG1_MSB:SEG1_LSB] = rblMuxSel[1][SEG1_MSB:SEG1_LSB];

                           array[my_arrayAddr+4][SEG1_MSB:SEG1_LSB]  = (~my_rblMuxSel[SEG1_MSB:SEG1_LSB] & array[my_arrayAddr+4][SEG1_MSB:SEG1_LSB]) |
                                                                       ( my_rblMuxSel[SEG1_MSB:SEG1_LSB] & my_w_data[SEG1_MSB:SEG1_LSB]);
                        end
                        if(my_ac[3:2]==2'd2) begin
                           array[my_arrayAddr  ][SEG1_MSB:SEG1_LSB]  = ( rblMuxSel[2][SEG1_MSB:SEG1_LSB] & array[my_arrayAddr][SEG1_MSB:SEG1_LSB]) |
                                                                       (~rblMuxSel[2][SEG1_MSB:SEG1_LSB] & my_w_data[SEG1_MSB:SEG1_LSB]);

                           if (rbfI[1][1:0]==2'd3) my_rblMuxSel[SEG1_MSB:SEG1_LSB] = rblMuxSel[3][SEG1_MSB:SEG1_LSB];
                           else                    my_rblMuxSel[SEG1_MSB:SEG1_LSB] = rblMuxSel[2][SEG1_MSB:SEG1_LSB];

                           array[my_arrayAddr+4][SEG1_MSB:SEG1_LSB]  = (~my_rblMuxSel[SEG1_MSB:SEG1_LSB] & array[my_arrayAddr+4][SEG1_MSB:SEG1_LSB]) |
                                                                       ( my_rblMuxSel[SEG1_MSB:SEG1_LSB] & my_w_data[SEG1_MSB:SEG1_LSB]);
                        end
                        if(my_ac[3:2]==2'd3) begin
                           array[my_arrayAddr  ][SEG1_MSB:SEG1_LSB]  = ( rblMuxSel[3][SEG1_MSB:SEG1_LSB] & array[my_arrayAddr][SEG1_MSB:SEG1_LSB]) |
                                                                       (~rblMuxSel[3][SEG1_MSB:SEG1_LSB] & my_w_data[SEG1_MSB:SEG1_LSB]);

                           arrayRBL[my_rblAddr][1]                   = (~rblMuxSel[3][SEG1_MSB] & arrayRBL[my_rblAddr][1]) |
                                                                       ( rblMuxSel[3][SEG1_MSB] & my_w_data[SEG1_MSB]);

                           if (rbfI[1][1:0]==2'd0) my_rblMuxSel[SEG1_MSB:SEG1_LSB] = rblMuxSel[3][SEG1_MSB:SEG1_LSB];
                           else                    my_rblMuxSel[SEG1_MSB:SEG1_LSB] = rblMuxSel[0][SEG1_MSB:SEG1_LSB];

                           array[my_arrayAddr2][SEG1_MSB:SEG1_LSB+1] = (~my_rblMuxSel[SEG1_MSB:SEG1_LSB+1] & array[my_arrayAddr2][SEG1_MSB:SEG1_LSB+1]) |
                                                                       ( my_rblMuxSel[SEG1_MSB:SEG1_LSB+1] & my_w_data[SEG1_MSB-1:SEG1_LSB]);
                        end
                     end // if (MUX==16)
                  end // else: !if(!rbeI[0])
               end // if (NUM_SEG>1)

               // Inject fails after doing the write
               if (any_fail) ForceFails;

            end // else: !if(i_rdwen)
 `endif //  `ifdef IVCS_FAST_FUNC
         end // if (!my_oob_address && (!i_rdwen || (i_rdwen && readOK)))
      end

   endtask

 `ifndef IVCS_FAST_FUNC
   ////////////////////////////////////////////////////////////////////////////
   // Fail injection support
   ////////////////////////////////////////////////////////////////////////////

   reg [A_SIZE:0] WL_FAIL_ADDR;
   reg [A_SIZE:0] WL_FAIL_RBLADDR;
   reg [A_SIZE:0] CELL0_FAIL_ADDR;
   reg [A_SIZE:0] CELL1_FAIL_ADDR;
   reg [A_SIZE:0] CELL2_FAIL_ADDR;
   reg [A_SIZE:0] CELL3_FAIL_ADDR;

   always @(*) begin

      if(startTrigger) begin

         // Wordline fail
         if (WL_FAIL_RWL_wire) begin
            WL_FAIL_ADDR    = W_DEPTH +
                              { WL_FAIL_SUB_wire[AS_SIZE-1:0],
                                WL_FAIL_ROW_wire[1:0],
                                {AC_SIZE{1'b0}} };

            WL_FAIL_RBLADDR = W_DEPTH +
                              { WL_FAIL_SUB_wire[AS_SIZE-1:0],
                                WL_FAIL_ROW_wire[1:0],
                                2'b00 };
         end
         else begin
            WL_FAIL_ADDR    = { WL_FAIL_ROW_wire[AW_SIZE-1:2],
                                WL_FAIL_SUB_wire[AS_SIZE-1:0],
                                WL_FAIL_ROW_wire[1:0],
                                {AC_SIZE{1'b0}} };

            WL_FAIL_RBLADDR = { WL_FAIL_ROW_wire[AW_SIZE-1:2],
                                WL_FAIL_SUB_wire[AS_SIZE-1:0],
                                WL_FAIL_ROW_wire[1:0],
                                2'b00 };
         end

         // Fail 0
         if (CELL0_FAIL_RBL_wire) begin
            CELL0_FAIL_ADDR = { CELL0_FAIL_ROW_wire[AW_SIZE-1:2],
                                CELL0_FAIL_SUB_wire[AS_SIZE-1:0],
                                CELL0_FAIL_ROW_wire[1:0],
                                CELL0_FAIL_COL_wire[1:0] };
         end
         else if (CELL0_FAIL_RWL_wire) begin
            CELL0_FAIL_ADDR = W_DEPTH +
                              { CELL0_FAIL_SUB_wire[AS_SIZE-1:0],
                                CELL0_FAIL_ROW_wire[1:0],
                                CELL0_FAIL_COL_wire[AC_SIZE-1:0] };
         end
         else begin
            CELL0_FAIL_ADDR = { CELL0_FAIL_ROW_wire[AW_SIZE-1:2],
                                CELL0_FAIL_SUB_wire[AS_SIZE-1:0],
                                CELL0_FAIL_ROW_wire[1:0],
                                CELL0_FAIL_COL_wire[AC_SIZE-1:0] };
         end

         // Fail 1
         if (CELL1_FAIL_RBL_wire) begin
            CELL1_FAIL_ADDR = { CELL1_FAIL_ROW_wire[AW_SIZE-1:2],
                                CELL1_FAIL_SUB_wire[AS_SIZE-1:0],
                                CELL1_FAIL_ROW_wire[1:0],
                                CELL1_FAIL_COL_wire[1:0] };
         end
         else if (CELL1_FAIL_RWL_wire) begin
            CELL1_FAIL_ADDR = W_DEPTH +
                              { CELL1_FAIL_SUB_wire[AS_SIZE-1:0],
                                CELL1_FAIL_ROW_wire[1:0],
                                CELL1_FAIL_COL_wire[AC_SIZE-1:0] };
         end
         else begin
            CELL1_FAIL_ADDR = { CELL1_FAIL_ROW_wire[AW_SIZE-1:2],
                                CELL1_FAIL_SUB_wire[AS_SIZE-1:0],
                                CELL1_FAIL_ROW_wire[1:0],
                                CELL1_FAIL_COL_wire[AC_SIZE-1:0] };
         end

         // Fail 2
         if (CELL2_FAIL_RBL_wire) begin
            CELL2_FAIL_ADDR = { CELL2_FAIL_ROW_wire[AW_SIZE-1:2],
                                CELL2_FAIL_SUB_wire[AS_SIZE-1:0],
                                CELL2_FAIL_ROW_wire[1:0],
                                CELL2_FAIL_COL_wire[1:0] };
         end
         else if (CELL2_FAIL_RWL_wire) begin
            CELL2_FAIL_ADDR = W_DEPTH +
                              { CELL2_FAIL_SUB_wire[AS_SIZE-1:0],
                                CELL2_FAIL_ROW_wire[1:0],
                                CELL2_FAIL_COL_wire[AC_SIZE-1:0] };
         end
         else begin
            CELL2_FAIL_ADDR = { CELL2_FAIL_ROW_wire[AW_SIZE-1:2],
                                CELL2_FAIL_SUB_wire[AS_SIZE-1:0],
                                CELL2_FAIL_ROW_wire[1:0],
                                CELL2_FAIL_COL_wire[AC_SIZE-1:0] };
         end

         // Fail 3
         if (CELL3_FAIL_RBL_wire) begin
            CELL3_FAIL_ADDR = { CELL3_FAIL_ROW_wire[AW_SIZE-1:2],
                                CELL3_FAIL_SUB_wire[AS_SIZE-1:0],
                                CELL3_FAIL_ROW_wire[1:0],
                                CELL3_FAIL_COL_wire[1:0] };
         end
         else if (CELL3_FAIL_RWL_wire) begin
            CELL3_FAIL_ADDR = W_DEPTH +
                              { CELL3_FAIL_SUB_wire[AS_SIZE-1:0],
                                CELL3_FAIL_ROW_wire[1:0],
                                CELL3_FAIL_COL_wire[AC_SIZE-1:0] };
         end
         else begin
            CELL3_FAIL_ADDR = { CELL3_FAIL_ROW_wire[AW_SIZE-1:2],
                                CELL3_FAIL_SUB_wire[AS_SIZE-1:0],
                                CELL3_FAIL_ROW_wire[1:0],
                                CELL3_FAIL_COL_wire[AC_SIZE-1:0] };
         end
      end // if (startTrigger)
   end // always @(*)


   integer k;

   always @(startTrigger or WL_FAIL_wire or WL_FAIL_ADDR or WL_FAIL_DATA_wire) begin
      if(WL_FAIL_wire) begin
         // Stick the fault into every column
         for(k=0; k<MUX; k=k+1) begin
            arrayRBL[WL_FAIL_RBLADDR+k[1:0]] = {2{WL_FAIL_DATA_wire}};
            array[WL_FAIL_ADDR+k]            = {D_SIZE{WL_FAIL_DATA_wire}};
         end
      end
   end

   always @(startTrigger or BL_FAIL_wire or BL_FAIL_COL_wire or BL_FAIL_BIT_wire or BL_FAIL_DATA_wire) begin
      if(BL_FAIL_wire) begin
         // Stick the fault into every word
         for(k=0; k<(W_DEPTH/MUX); k=k+1) begin
            if (BL_FAIL_RBL_wire) begin
               arrayRBL[{k[(AS_SIZE+AW_SIZE-1):0], BL_FAIL_COL_wire[1:0]}][BL_FAIL_BIT_wire[0]] = BL_FAIL_DATA_wire;
            end
            else begin
               array[{k[(AS_SIZE+AW_SIZE-1):0], BL_FAIL_COL_wire[AC_SIZE-1:0]}][BL_FAIL_BIT_wire] = BL_FAIL_DATA_wire;
            end
         end
      end
   end


   // Should call this just before doing a read and just after doing a write
   task ForceFails;

      begin

         if(WL_FAIL_wire) begin
            array[WL_FAIL_ADDR+acI]            = {D_SIZE{WL_FAIL_DATA_wire}};
            arrayRBL[WL_FAIL_RBLADDR+acI[1:0]] = {D_SIZE{WL_FAIL_DATA_wire}};
         end

         if(BL_FAIL_wire) begin
            if (BL_FAIL_RBL_wire) begin
               arrayRBL[{awI[AW_SIZE-1:2], asI, awI[1:0], BL_FAIL_COL_wire[1:0]}][BL_FAIL_BIT] = BL_FAIL_DATA_wire;
            end
            else begin
               array[{awI[AW_SIZE-1:2], asI, awI[1:0], BL_FAIL_COL_wire[AC_SIZE-1:0]}][BL_FAIL_BIT] = BL_FAIL_DATA_wire;
            end
         end

         if(CELL0_FAIL_wire) begin
            if (CELL0_FAIL_RBL_wire) begin
               arrayRBL[CELL0_FAIL_ADDR][CELL0_FAIL_BIT_wire] = CELL0_FORCE_DATA_wire;
            end
            else begin
               array[CELL0_FAIL_ADDR][CELL0_FAIL_BIT_wire] = CELL0_FORCE_DATA_wire;
            end
         end

         if(CELL1_FAIL_wire) begin
            if (CELL1_FAIL_RBL_wire) begin
               arrayRBL[CELL1_FAIL_ADDR][CELL1_FAIL_BIT_wire] = CELL1_FORCE_DATA_wire;
            end
            else begin
               array[CELL1_FAIL_ADDR][CELL1_FAIL_BIT_wire] = CELL1_FORCE_DATA_wire;
            end
         end

         if(CELL2_FAIL_wire) begin
            if (CELL2_FAIL_RBL_wire) begin
               arrayRBL[CELL2_FAIL_ADDR][CELL2_FAIL_BIT_wire] = CELL2_FORCE_DATA_wire;
            end
            else begin
               array[CELL2_FAIL_ADDR][CELL2_FAIL_BIT_wire] = CELL2_FORCE_DATA_wire;
            end
         end

         if(CELL3_FAIL_wire) begin
            if (CELL3_FAIL_RBL_wire) begin
               arrayRBL[CELL3_FAIL_ADDR][CELL3_FAIL_BIT_wire] = CELL3_FORCE_DATA_wire;
            end
            else begin
               array[CELL3_FAIL_ADDR][CELL3_FAIL_BIT_wire] = CELL3_FORCE_DATA_wire;
            end
         end

      end

   endtask
 `endif //  `ifndef IVCS_FAST_FUNC


   ////////////////////////////////////////////////////////////////////////////
   // Use these tasks to write errors/warnings/info messages to the console
   ////////////////////////////////////////////////////////////////////////////

   task ERROR_TASK;
      input [3:0] trigger;
      input [8*200-1:0] msg;
      begin
         if (((MSG_LVL==1)||(MSG_LVL==2)) && !msgTrigger[trigger]) begin
            $display("%m: At time %0t %0s", $time, msg);
            $display("%m: This error will be issued on first occurrence only.");
            msgTrigger[trigger]=1'b1;
         end
         if (MSG_LVL > 2) begin
            $display("%m: At time %0t %0s", $time, msg);
         end
      end
   endtask

   task WARNING_TASK;
      input [3:0] trigger;
      input [8*200-1:0] msg;
      begin
         if ((MSG_LVL == 2) && !msgTrigger[trigger]) begin
            $display("%m: At time %0t %0s", $time, msg);
            $display("%m: This warning will be issued on first occurrence only.");
            msgTrigger[trigger]=1'b1;
         end
         if (MSG_LVL > 2) begin
            $display("%m: At time %0t %0s", $time, msg);
         end
      end
   endtask

   task INFO_TASK;
      input [3:0] trigger;
      input [8*200-1:0] msg;
      begin
         if ((MSG_LVL == 2) && !msgTrigger[trigger]) begin
            $display("%m: At time %0t %0s", $time, msg);
            $display("%m: This message will be issued on first occurrence only.");
            msgTrigger[trigger]=1'b1;
         end
         if (MSG_LVL > 2) begin
            $display("%m: At time %0t %0s", $time, msg);
         end
      end
   endtask

   function [23:0] str;
      input [8:0] val;
      begin
         str[23:16] = (val<100) ? " " : 48+(val/100);
         str[15: 8] = (val< 10) ? " " : 48+((val%100)/10);
         str[ 7: 0] = 48+(val%10);
      end
   endfunction


   ////////////////////////////////////////////////////////////////////////////
   // Call this task when we need to blanket write the array
   ////////////////////////////////////////////////////////////////////////////

   task BlanketWriteArray;
      input data;
      integer i;
      begin
         for (i=0;i<ARRAY_DEPTH;i=i+1) begin
            array[i] <= {D_SIZE{data}};
         end
 `ifndef IVCS_FAST_FUNC
         for (i=0;i<RBL_DEPTH;i=i+1) begin
            arrayRBL[i] <= {2{data}};
         end
 `endif
      end
   endtask
`endif // !`ifdef IVCS_CYCLE_SIM


   ////////////////////////////////////////////////////////////////////////////
   // Call one of these tasks to load the contents of the memory from a file
   ////////////////////////////////////////////////////////////////////////////

   task LoadArrayFromBinFile;
      input [8*128-1:0] filename;
      begin
         $display("Preloading array at time %0t with contents of binary data file %0s", $time, filename);
         $readmemb(filename, array);
      end
   endtask

   task LoadArrayFromHexFile;
      input [8*128-1:0] filename;
      begin
         $display("Preloading array at time %0t with contents of hexadecimal data file %0s", $time, filename);
         $readmemh(filename, array);
      end
   endtask


   ////////////////////////////////////////////////////////////////////////////
   // Call this task to dump the contents of the memory
   // Uses a format compatible with $readmemb
   ////////////////////////////////////////////////////////////////////////////

   task DumpArray;
      integer i;
      begin
         $display("\n//////// BEGIN %m ////////");
         for (i=0;i<W_DEPTH;i=i+1) begin
            $display("@%1h %b", i, array[i]);
         end
         $display("////////  END  %m ////////\n");
      end
   endtask

endmodule
